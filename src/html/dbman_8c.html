<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Kalashnikov DBBBB: dm/dbman.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalashnikov DBBBB
   &#160;<span id="projectnumber">2.2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_fceb8c84259f2f7a80548922c61f7c5a.html">dm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">dbman.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="dbman_8h_source.html">dbman.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for dbman.c:</div>
<div class="dyncontent">
<div class="center"><img src="dbman_8c__incl.png" border="0" usemap="#dm_2dbman_8c" alt=""/></div>
<map name="dm_2dbman_8c" id="dm_2dbman_8c">
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7cacca7e9aebff2aee36f85632e5c35e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a7cacca7e9aebff2aee36f85632e5c35e">AK_init_db_file</a> (int size)</td></tr>
<tr class="memdesc:a7cacca7e9aebff2aee36f85632e5c35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initializes a new database file named DB_FILE. It opens database file. New block is allocated. In this block type of header is set to FREE_INT, attribute names are set to FREE_CHAR, integrities are set to FREE_INT, constraint names are set to FREE_CHAR, constraint names and codes are set to FREE_CHAR. Type, address and size of tuples are set to FREE_INT. Data in block is set to FREE_CHAR. Type of block is BLOCK_TYPE_FREE, it is not chained and id of last tuple is 0.  <a href="#a7cacca7e9aebff2aee36f85632e5c35e">More...</a><br /></td></tr>
<tr class="separator:a7cacca7e9aebff2aee36f85632e5c35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377b7d3e346a2cbe608d468f4274cda8"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a377b7d3e346a2cbe608d468f4274cda8">AK_get_allocation_set</a> (int *bitsetbs, int fromWhere, int gaplength, int num, <a class="el" href="dbman_8h.html#af6d80074e26af6570de6d650c1d90851">AK_allocation_set_mode</a> mode, int target)</td></tr>
<tr class="memdesc:a377b7d3e346a2cbe608d468f4274cda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function prepare demanded sets from allocation table.  <a href="#a377b7d3e346a2cbe608d468f4274cda8">More...</a><br /></td></tr>
<tr class="separator:a377b7d3e346a2cbe608d468f4274cda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf09d102942a1534d53d89489591af1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#acf09d102942a1534d53d89489591af1b">AK_allocationtable_dump</a> (int zz)</td></tr>
<tr class="memdesc:acf09d102942a1534d53d89489591af1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function dumpes allocation table.  <a href="#acf09d102942a1534d53d89489591af1b">More...</a><br /></td></tr>
<tr class="separator:acf09d102942a1534d53d89489591af1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3956a7198427c0911c2775d382842b98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a3956a7198427c0911c2775d382842b98">AK_blocktable_dump</a> (int zz)</td></tr>
<tr class="memdesc:a3956a7198427c0911c2775d382842b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function dumpes allocation table.  <a href="#a3956a7198427c0911c2775d382842b98">More...</a><br /></td></tr>
<tr class="separator:a3956a7198427c0911c2775d382842b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4ddae5253862ad465b91b1e940a71f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#aef4ddae5253862ad465b91b1e940a71f">AK_blocktable_flush</a> ()</td></tr>
<tr class="memdesc:aef4ddae5253862ad465b91b1e940a71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function flushes bitmask table to disk.  <a href="#aef4ddae5253862ad465b91b1e940a71f">More...</a><br /></td></tr>
<tr class="separator:aef4ddae5253862ad465b91b1e940a71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a5fe4ed50be350e3c9d9d20a57afbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#ab4a5fe4ed50be350e3c9d9d20a57afbe">AK_allocate_block_activity_modes</a> ()</td></tr>
<tr class="memdesc:ab4a5fe4ed50be350e3c9d9d20a57afbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation of array which will contain information about which blocks are being accessed. Creates an array. Each element of this array will correspond to one initialized block. For more info, see explanation in <a class="el" href="dbman_8h.html">dbman.h</a>.  <a href="#ab4a5fe4ed50be350e3c9d9d20a57afbe">More...</a><br /></td></tr>
<tr class="separator:ab4a5fe4ed50be350e3c9d9d20a57afbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ad69e55d09ab4aa2bec6dd34805367"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a41ad69e55d09ab4aa2bec6dd34805367">AK_thread_safe_block_access_test</a> ()</td></tr>
<tr class="memdesc:a41ad69e55d09ab4aa2bec6dd34805367"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests thread safe reading and writing to blocks. There is N writing and N reading threads, which are going through iterations. Each reading thread should read the data (character) that was set by last writing thread.  <a href="#a41ad69e55d09ab4aa2bec6dd34805367">More...</a><br /></td></tr>
<tr class="separator:a41ad69e55d09ab4aa2bec6dd34805367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5499694bd97b104560d14ef70abe2c73"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a5499694bd97b104560d14ef70abe2c73">AK_read_block_for_testing</a> (void *address)</td></tr>
<tr class="memdesc:a5499694bd97b104560d14ef70abe2c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is only for testing. It has to be there, because pthread_create only accepts void* function_name (void *) function format. So AK_read_block is no-go for pthread_create.  <a href="#a5499694bd97b104560d14ef70abe2c73">More...</a><br /></td></tr>
<tr class="separator:a5499694bd97b104560d14ef70abe2c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0558e034eeed865a1c855de5cfad20ef"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a0558e034eeed865a1c855de5cfad20ef">AK_write_block_for_testing</a> (void *block)</td></tr>
<tr class="memdesc:a0558e034eeed865a1c855de5cfad20ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is only for testing. It has to be there, because pthread_create only accepts void* function_name (void *) function format. So AK_write_block is no-go for pthread_create.  <a href="#a0558e034eeed865a1c855de5cfad20ef">More...</a><br /></td></tr>
<tr class="separator:a0558e034eeed865a1c855de5cfad20ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfd5252c0eed066034b558df30cc790"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#adcfd5252c0eed066034b558df30cc790">AK_blocktable_get</a> ()</td></tr>
<tr class="memdesc:adcfd5252c0eed066034b558df30cc790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function gets allocation table from disk.  <a href="#adcfd5252c0eed066034b558df30cc790">More...</a><br /></td></tr>
<tr class="separator:adcfd5252c0eed066034b558df30cc790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc6978517271fbd48a004cb039ac6c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#adbc6978517271fbd48a004cb039ac6c1">fsize</a> (FILE *fp)</td></tr>
<tr class="memdesc:adbc6978517271fbd48a004cb039ac6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to determine file size.  <a href="#adbc6978517271fbd48a004cb039ac6c1">More...</a><br /></td></tr>
<tr class="separator:adbc6978517271fbd48a004cb039ac6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0b4429858370953a410c6fb5b9ec92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#aee0b4429858370953a410c6fb5b9ec92">AK_init_allocation_table</a> ()</td></tr>
<tr class="memdesc:aee0b4429858370953a410c6fb5b9ec92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initializes allocation table, write it to disk and cache in memory.  <a href="#aee0b4429858370953a410c6fb5b9ec92">More...</a><br /></td></tr>
<tr class="separator:aee0b4429858370953a410c6fb5b9ec92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402f984ce7298e193a2a9c5dc5d6b901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a402f984ce7298e193a2a9c5dc5d6b901">AK_init_block</a> ()</td></tr>
<tr class="memdesc:a402f984ce7298e193a2a9c5dc5d6b901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initializes new block.  <a href="#a402f984ce7298e193a2a9c5dc5d6b901">More...</a><br /></td></tr>
<tr class="separator:a402f984ce7298e193a2a9c5dc5d6b901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcca519b1dbe309c683d64b0e955dca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a3fcca519b1dbe309c683d64b0e955dca">AK_print_block</a> (<a class="el" href="structAK__block.html">AK_block</a> *block, int num, char *gg, FILE *fpp)</td></tr>
<tr class="memdesc:a3fcca519b1dbe309c683d64b0e955dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that dumps block.  <a href="#a3fcca519b1dbe309c683d64b0e955dca">More...</a><br /></td></tr>
<tr class="separator:a3fcca519b1dbe309c683d64b0e955dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48b8ab357cefa4ffcc54c348571c1fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#ac48b8ab357cefa4ffcc54c348571c1fe">AK_allocate_blocks</a> (FILE *<a class="el" href="dbman_8h.html#a89a7f6028a19c3dc081cc5f16eb53891">db</a>, <a class="el" href="structAK__block.html">AK_block</a> *block, int FromWhere, int HowMany)</td></tr>
<tr class="memdesc:ac48b8ab357cefa4ffcc54c348571c1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that allocates new blocks by placing them to appropriate place and then update last initialized index.  <a href="#ac48b8ab357cefa4ffcc54c348571c1fe">More...</a><br /></td></tr>
<tr class="separator:ac48b8ab357cefa4ffcc54c348571c1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c880db7cf4f8332ae7e93c6b71cc911"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a2c880db7cf4f8332ae7e93c6b71cc911">AK_read_block</a> (int address)</td></tr>
<tr class="memdesc:a2c880db7cf4f8332ae7e93c6b71cc911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads a block at a given address (block number less than db_file_size). New block is allocated. Database file is opened. Position is set to provided address block. At the end function reads file from that position. Completely thread-safe.  <a href="#a2c880db7cf4f8332ae7e93c6b71cc911">More...</a><br /></td></tr>
<tr class="separator:a2c880db7cf4f8332ae7e93c6b71cc911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222ea31aa276d52e464137a3b144f78a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a222ea31aa276d52e464137a3b144f78a">AK_write_block</a> (<a class="el" href="structAK__block.html">AK_block</a> *block)</td></tr>
<tr class="memdesc:a222ea31aa276d52e464137a3b144f78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function writes a block to DB file. Database file is opened. Position is set to provided address block. Block is written to provided address. Completely thread-safe.  <a href="#a222ea31aa276d52e464137a3b144f78a">More...</a><br /></td></tr>
<tr class="separator:a222ea31aa276d52e464137a3b144f78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d4a6ea2344a3003ea50930cc0e77b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#ad4d4a6ea2344a3003ea50930cc0e77b8">AK_copy_header</a> (<a class="el" href="structAK__header.html">AK_header</a> *header, int *blocknum, int num)</td></tr>
<tr class="memdesc:ad4d4a6ea2344a3003ea50930cc0e77b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function copy header to blocks. Completely thread-safe.  <a href="#ad4d4a6ea2344a3003ea50930cc0e77b8">More...</a><br /></td></tr>
<tr class="separator:ad4d4a6ea2344a3003ea50930cc0e77b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9525b11c47b5825abb4956add526623c"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a9525b11c47b5825abb4956add526623c">AK_get_extent</a> (int start_address, int desired_size, <a class="el" href="dbman_8h.html#af6d80074e26af6570de6d650c1d90851">AK_allocation_set_mode</a> *mode, int border, int target, <a class="el" href="structAK__header.html">AK_header</a> *header, int gl)</td></tr>
<tr class="memdesc:a9525b11c47b5825abb4956add526623c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function alocates new extent of blocks. Number of blocks is not ordered as well as a way of search for them.  <a href="#a9525b11c47b5825abb4956add526623c">More...</a><br /></td></tr>
<tr class="separator:a9525b11c47b5825abb4956add526623c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9411aae916046fdd8e53ed1760a58b6d"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a9411aae916046fdd8e53ed1760a58b6d">AK_increase_extent</a> (int start_address, int add_size, <a class="el" href="dbman_8h.html#af6d80074e26af6570de6d650c1d90851">AK_allocation_set_mode</a> *mode, int border, int target, <a class="el" href="structAK__header.html">AK_header</a> *header, int gl)</td></tr>
<tr class="memdesc:a9411aae916046fdd8e53ed1760a58b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function alocates new blocks for increasing extent size.  <a href="#a9411aae916046fdd8e53ed1760a58b6d">More...</a><br /></td></tr>
<tr class="separator:a9411aae916046fdd8e53ed1760a58b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff7d6ea92a45cda91ff2063043900a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a1ff7d6ea92a45cda91ff2063043900a1">AK_new_extent</a> (int start_address, int old_size, int extent_type, <a class="el" href="structAK__header.html">AK_header</a> *header)</td></tr>
<tr class="memdesc:a1ff7d6ea92a45cda91ff2063043900a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function alocates new extent of blocks. If argument "old_size" is 0 than size of extent is INITIAL_EXTENT_SIZE. Otherwise, resize factor is set according to type of extent. If writing of block is successful, number of blocks is incremented.  <a href="#a1ff7d6ea92a45cda91ff2063043900a1">More...</a><br /></td></tr>
<tr class="separator:a1ff7d6ea92a45cda91ff2063043900a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e7998e69e2910528f7ef258469b2be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a79e7998e69e2910528f7ef258469b2be">AK_new_segment</a> (char *name, int type, <a class="el" href="structAK__header.html">AK_header</a> *header)</td></tr>
<tr class="memdesc:a79e7998e69e2910528f7ef258469b2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that allocates new segment of extents. In this phase of implementation, only extents containing INITIAL_EXTENT_SIZE blocks can be allocated. If extent is successfully allocated, number of allocated extents is incremented and function goes to next block after allocated extent. Otherwise, function moves to INITIAL_EXTENT_SIZE blocks. In that way function gets either first block of new extent or some block in that extent which will not be AK_free.  <a href="#a79e7998e69e2910528f7ef258469b2be">More...</a><br /></td></tr>
<tr class="separator:a79e7998e69e2910528f7ef258469b2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd8d4f27d7e825392badfcfc4baf968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#adbd8d4f27d7e825392badfcfc4baf968">AK_create_header</a> (char *name, int type, int integrity, char *constr_name, char *contr_code)</td></tr>
<tr class="memdesc:adbd8d4f27d7e825392badfcfc4baf968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for creating header and initalize integrity, constraint name and constraint code with parameter values of function.  <a href="#adbd8d4f27d7e825392badfcfc4baf968">More...</a><br /></td></tr>
<tr class="separator:adbd8d4f27d7e825392badfcfc4baf968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f011234546a9f1cc751a0d08036b131"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a0f011234546a9f1cc751a0d08036b131">AK_insert_entry</a> (<a class="el" href="structAK__block.html">AK_block</a> *block_address, int type, void *entry_data, int i)</td></tr>
<tr class="memdesc:a0f011234546a9f1cc751a0d08036b131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for inserting entry in tuple_dict and data of a block. Address, type and size of catalog_tuple_dict are set. Free space of block is also set.  <a href="#a0f011234546a9f1cc751a0d08036b131">More...</a><br /></td></tr>
<tr class="separator:a0f011234546a9f1cc751a0d08036b131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48430852cddc2cc7b79dd2775212b10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#ac48430852cddc2cc7b79dd2775212b10">AK_init_system_tables_catalog</a> (int relation, int attribute, int index, int view, int sequence, int function, int function_arguments, int trigger, int trigger_conditions, int <a class="el" href="dbman_8h.html#a89a7f6028a19c3dc081cc5f16eb53891">db</a>, int db_obj, int user, int group, int user_group, int user_right, int group_right, int constraint, int constraintNull, int constraintCheck, int constraintUnique, int reference)</td></tr>
<tr class="memdesc:ac48430852cddc2cc7b79dd2775212b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function initialises the sytem table catalog and writes the result in first (0) block in db_file. Catalog block, catalog header name, catalog header address are allocated. Address, type, chained_with and AK_free_space attributes are initialized. Names of various database elements are written in block.  <a href="#ac48430852cddc2cc7b79dd2775212b10">More...</a><br /></td></tr>
<tr class="separator:ac48430852cddc2cc7b79dd2775212b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3157bc3da79c19192a915acc1235bad0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a3157bc3da79c19192a915acc1235bad0">AK_memset_int</a> (void *block, int value, size_t num)</td></tr>
<tr class="memdesc:a3157bc3da79c19192a915acc1235bad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that sets the first num ints of a block of memory to the specified value.  <a href="#a3157bc3da79c19192a915acc1235bad0">More...</a><br /></td></tr>
<tr class="separator:a3157bc3da79c19192a915acc1235bad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c050534ddf6dcf1cba09987424ff76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#af4c050534ddf6dcf1cba09987424ff76">AK_register_system_tables</a> (int relation, int attribute, int index, int view, int sequence, int function, int function_arguments, int trigger, int trigger_conditions, int <a class="el" href="dbman_8h.html#a89a7f6028a19c3dc081cc5f16eb53891">db</a>, int db_obj, int user, int group, int user_group, int user_right, int group_right, int constraint, int constraintNull, int constraintCheck, int constraintUnique, int reference)</td></tr>
<tr class="memdesc:af4c050534ddf6dcf1cba09987424ff76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that registers system tables. Block at the given address is read. Various data from function arguments are written in block about different database elements.  <a href="#af4c050534ddf6dcf1cba09987424ff76">More...</a><br /></td></tr>
<tr class="separator:af4c050534ddf6dcf1cba09987424ff76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99cdc5c8456ad5ff87fb542d030c4d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#af99cdc5c8456ad5ff87fb542d030c4d6">AK_init_system_catalog</a> ()</td></tr>
<tr class="memdesc:af99cdc5c8456ad5ff87fb542d030c4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function initializes the system catalog. Headers for system tables are defined. Segments for those system tables are allocated. Above function <a class="el" href="dbman_8c.html#af4c050534ddf6dcf1cba09987424ff76" title="Function that registers system tables. Block at the given address is read. Various data from function...">AK_register_system_tables()</a> to register system tables.  <a href="#af99cdc5c8456ad5ff87fb542d030c4d6">More...</a><br /></td></tr>
<tr class="separator:af99cdc5c8456ad5ff87fb542d030c4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5058a1dd8adfdd5663626492f1d1f257"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a5058a1dd8adfdd5663626492f1d1f257">AK_delete_block</a> (int address)</td></tr>
<tr class="memdesc:a5058a1dd8adfdd5663626492f1d1f257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function deletes a block by a given block address (resets the header and data). Types, integrities, constraint names, constraint codes are set to "AK_free" values. In tuple dictionary type, address and size are set to FREE_INT values. Data of block is set to FREE_CHAR.  <a href="#a5058a1dd8adfdd5663626492f1d1f257">More...</a><br /></td></tr>
<tr class="separator:a5058a1dd8adfdd5663626492f1d1f257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0ef3161f926bef80f12aa4e0905acd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a1c0ef3161f926bef80f12aa4e0905acd">AK_delete_extent</a> (int begin, int end)</td></tr>
<tr class="memdesc:a1c0ef3161f926bef80f12aa4e0905acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function deletes an extent between begin and end blocks.  <a href="#a1c0ef3161f926bef80f12aa4e0905acd">More...</a><br /></td></tr>
<tr class="separator:a1c0ef3161f926bef80f12aa4e0905acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6e9ee9800548168a235c26fcceba71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a0a6e9ee9800548168a235c26fcceba71">AK_delete_segment</a> (char *name, int type)</td></tr>
<tr class="separator:a0a6e9ee9800548168a235c26fcceba71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7d6a4c56ce0c15b59217a3607db06e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a7e7d6a4c56ce0c15b59217a3607db06e">AK_init_disk_manager</a> ()</td></tr>
<tr class="separator:a7e7d6a4c56ce0c15b59217a3607db06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195049d1c2185a540f18cf1711e2f448"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a195049d1c2185a540f18cf1711e2f448"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AK_allocationbit_test</b> ()</td></tr>
<tr class="separator:a195049d1c2185a540f18cf1711e2f448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e134c23957bd5971723676e5fb4a2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35e134c23957bd5971723676e5fb4a2d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AK_allocationtable_test</b> ()</td></tr>
<tr class="separator:a35e134c23957bd5971723676e5fb4a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa74b62e850a091e2305da8dc8ab1e1de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa74b62e850a091e2305da8dc8ab1e1de"></a>
pthread_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><b>fileLockMutex</b> = PTHREAD_MUTEX_INITIALIZER</td></tr>
<tr class="separator:aa74b62e850a091e2305da8dc8ab1e1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d8194a70159d3603f73699e7f1ed6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75d8194a70159d3603f73699e7f1ed6f"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a75d8194a70159d3603f73699e7f1ed6f">test_lastCharacterWritten</a> = '\0'</td></tr>
<tr class="memdesc:a75d8194a70159d3603f73699e7f1ed6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable is used only when TEST_MODE is ON! It is used only for testing functionality of <a class="el" href="dbman_8c.html#a41ad69e55d09ab4aa2bec6dd34805367" title="This function tests thread safe reading and writing to blocks. There is N writing and N reading threa...">AK_thread_safe_block_access_test()</a> function. It will contain first character of last written block. When reading thread reads the block (written by some other thread), it will compare the first character from this block to character containted in this wariables. If they don't match, then the error occured! It is assumed that the same block is being written to and read from (just like AK_thread_safe_block_access_test function works!) <br /></td></tr>
<tr class="separator:a75d8194a70159d3603f73699e7f1ed6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8ef161a5a8600479cc77f15d7b859e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef8ef161a5a8600479cc77f15d7b859e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#aef8ef161a5a8600479cc77f15d7b859e">test_threadSafeBlockAccessSucceeded</a> = 1</td></tr>
<tr class="memdesc:aef8ef161a5a8600479cc77f15d7b859e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in combination with test_lastCharacterWritten. Will give the answer to question: "Has AK_thread_safe_block_access_test suceeded?" 0 means NO, 1 means YES. <br /></td></tr>
<tr class="separator:aef8ef161a5a8600479cc77f15d7b859e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines functions for the disk manager </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab4a5fe4ed50be350e3c9d9d20a57afbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_allocate_block_activity_modes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocation of array which will contain information about which blocks are being accessed. Creates an array. Each element of this array will correspond to one initialized block. For more info, see explanation in <a class="el" href="dbman_8h.html">dbman.h</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Domagoj Šitum </dd></dl>

</div>
</div>
<a class="anchor" id="ac48b8ab357cefa4ffcc54c348571c1fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_allocate_blocks </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>FromWhere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>HowMany</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that allocates new blocks by placing them to appropriate place and then update last initialized index. </p>
<dl class="section author"><dt>Author</dt><dd>Markus Schatten , rearranged by dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the file has been written to disk, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="acf09d102942a1534d53d89489591af1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_allocationtable_dump </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function dumpes allocation table. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>nothing </dd></dl>

</div>
</div>
<a class="anchor" id="a3956a7198427c0911c2775d382842b98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_blocktable_dump </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function dumpes allocation table. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>nothing </dd></dl>

</div>
</div>
<a class="anchor" id="aef4ddae5253862ad465b91b1e940a71f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_blocktable_flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function flushes bitmask table to disk. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the file has been written to disk, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="adcfd5252c0eed066034b558df30cc790"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_blocktable_get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function gets allocation table from disk. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the file has been taken from disk, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad4d4a6ea2344a3003ea50930cc0e77b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_copy_header </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>blocknum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function copy header to blocks. Completely thread-safe. </p>
<dl class="section author"><dt>Author</dt><dd>Nikola Bakoš, updated by Dino Laktašiæ (fixed header BUG), refurbished by dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>pointer to header provided for copy </td></tr>
    <tr><td class="paramname">blocknum</td><td>pointer to addresses of blocks that header needs to be copied </td></tr>
    <tr><td class="paramname">num</td><td>number of blocks waiting for its header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of performed header copy </dd></dl>
<p>var to check the number of written blocks</p>
<p>if write of block succeded increase var num_blocks, else nothing </p>

</div>
</div>
<a class="anchor" id="adbd8d4f27d7e825392badfcfc4baf968"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAK__header.html">AK_header</a>* AK_create_header </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>integrity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>constr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>contr_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for creating header and initalize integrity, constraint name and constraint code with parameter values of function. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the atribute </td></tr>
    <tr><td class="paramname">type</td><td>type of the atribute </td></tr>
    <tr><td class="paramname">integrity</td><td>standard integrity costraint </td></tr>
    <tr><td class="paramname">constr_name</td><td>extra integrity constraint name </td></tr>
    <tr><td class="paramname">contr_code</td><td>extra integrity costraint code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structAK__header.html" title="Structure that represents header structure of blocks (describes an attribute inside an object)...">AK_header</a> </dd></dl>
<p>initialize catalog_header-&gt;integrity and catalog_header-&gt;constr_name[][] and catalog_header-&gt;constr_code[][] with data given as functions parameters </p>

</div>
</div>
<a class="anchor" id="a5058a1dd8adfdd5663626492f1d1f257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_delete_block </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function deletes a block by a given block address (resets the header and data). Types, integrities, constraint names, constraint codes are set to "AK_free" values. In tuple dictionary type, address and size are set to FREE_INT values. Data of block is set to FREE_CHAR. </p>
<dl class="section author"><dt>Author</dt><dd>Markus Schatten </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>address of the block to be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns EXIT_SUCCESS if deletion successful, else EXIT_ERROR </dd></dl>

</div>
</div>
<a class="anchor" id="a1c0ef3161f926bef80f12aa4e0905acd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_delete_extent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function deletes an extent between begin and end blocks. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Samboliæ </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>address of extent's first block </td></tr>
    <tr><td class="paramname">end</td><td>address of extent's last block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if extent has been successfully deleted, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a0a6e9ee9800548168a235c26fcceba71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_delete_segment </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Mislav Èakariæ </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the segment </td></tr>
    <tr><td class="paramname">type</td><td>type of the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if extent has been successfully deleted, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a377b7d3e346a2cbe608d468f4274cda8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* AK_get_allocation_set </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bitsetbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fromWhere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gaplength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbman_8h.html#af6d80074e26af6570de6d650c1d90851">AK_allocation_set_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function prepare demanded sets from allocation table. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitset</td><td>int pointer, cointainer for bit set </td></tr>
    <tr><td class="paramname">fromWhere</td><td>has meaning just in SEQUENCE case. It describes from which address searching have to start. </td></tr>
    <tr><td class="paramname">gaplength</td><td>tells how many used blocks could be tolerated in bitset </td></tr>
    <tr><td class="paramname">num</td><td>Tells how many AK_free blocks has been needed </td></tr>
    <tr><td class="paramname">mode</td><td>Defines how to obtain set of indexes to AK_free addresses </td></tr>
    <tr><td class="paramname">target</td><td>has meaning just in case mode=AROUND: set must be as much as possible close to target from both sides </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to integer indexes field with prepared set. If it , for any reason, is not possible set has FREE_INT fullfilment. </dd></dl>

</div>
</div>
<a class="anchor" id="a9525b11c47b5825abb4956add526623c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* AK_get_extent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>desired_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbman_8h.html#af6d80074e26af6570de6d650c1d90851">AK_allocation_set_mode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function alocates new extent of blocks. Number of blocks is not ordered as well as a way of search for them. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_address</td><td>address (block number) to start searching for sufficient space </td></tr>
    <tr><td class="paramname">desired_size</td><td>number of desired blocks </td></tr>
    <tr><td class="paramname">AK_allocation_set_mode</td><td>a way of trying to fing AK_free space. Can be one of: allocationSEQUENCE, allocationUPPER, allocationLOWER, allocationAROUND </td></tr>
    <tr><td class="paramname">border</td><td>number of allocated blocks gap </td></tr>
    <tr><td class="paramname">target</td><td>block address around which other blocks have to be searched </td></tr>
    <tr><td class="paramname">header</td><td>pointer to header that should be written to the new extent (all blocks) </td></tr>
    <tr><td class="paramname">int</td><td>gl gap size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to set of alocated block addresses </dd></dl>
<p>vars for loop [for]</p>
<p>if some blocks are not succesfully allocated, which means that the extend allocation has FAILED </p>

</div>
</div>
<a class="anchor" id="a9411aae916046fdd8e53ed1760a58b6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* AK_increase_extent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>add_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbman_8h.html#af6d80074e26af6570de6d650c1d90851">AK_allocation_set_mode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function alocates new blocks for increasing extent size. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_address</td><td>first address of extent that is subject of increasing </td></tr>
    <tr><td class="paramname">add_size</td><td>number how many new blocks is to be added to existing extent </td></tr>
    <tr><td class="paramname">AK_allocation_set_mode</td><td>a way of trying to fing AK_free space. Can be one of: allocationSEQUENCE, allocationUPPER, allocationLOWER, allocationAROUND </td></tr>
    <tr><td class="paramname">border</td><td>number of allocated blocks gap </td></tr>
    <tr><td class="paramname">target</td><td>block address around which other blocks have to be searched </td></tr>
    <tr><td class="paramname">header</td><td>pointer to header that should be written to the new extent (all blocks) </td></tr>
    <tr><td class="paramname">int</td><td>gl gap size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to set of alocated block addresses </dd></dl>
<p>vars for loop [for] </p>

</div>
</div>
<a class="anchor" id="aee0b4429858370953a410c6fb5b9ec92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_init_allocation_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initializes allocation table, write it to disk and cache in memory. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the file has been written to disk, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a402f984ce7298e193a2a9c5dc5d6b901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAK__block.html">AK_block</a>* AK_init_block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initializes new block. </p>
<dl class="section author"><dt>Author</dt><dd>Markus Schatten , rearranged by dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to block allocated in memory </dd></dl>

</div>
</div>
<a class="anchor" id="a7cacca7e9aebff2aee36f85632e5c35e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_init_db_file </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initializes a new database file named DB_FILE. It opens database file. New block is allocated. In this block type of header is set to FREE_INT, attribute names are set to FREE_CHAR, integrities are set to FREE_INT, constraint names are set to FREE_CHAR, constraint names and codes are set to FREE_CHAR. Type, address and size of tuples are set to FREE_INT. Data in block is set to FREE_CHAR. Type of block is BLOCK_TYPE_FREE, it is not chained and id of last tuple is 0. </p>
<dl class="section author"><dt>Author</dt><dd>Markus Schatten </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of new file in in blocks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the file has been written to disk, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a7e7d6a4c56ce0c15b59217a3607db06e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_init_disk_manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Markus Schatten </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Function that calls functions <a class="el" href="dbman_8c.html#a7cacca7e9aebff2aee36f85632e5c35e" title="Function that initializes a new database file named DB_FILE. It opens database file. New block is allocated. In this block type of header is set to FREE_INT, attribute names are set to FREE_CHAR, integrities are set to FREE_INT, constraint names are set to FREE_CHAR, constraint names and codes are set to FREE_CHAR. Type, address and size of tuples are set to FREE_INT. Data in block is set to FREE_CHAR. Type of block is BLOCK_TYPE_FREE, it is not chained and id of last tuple is 0. ">AK_init_db_file()</a> and <a class="el" href="dbman_8c.html#af99cdc5c8456ad5ff87fb542d030c4d6" title="Function initializes the system catalog. Headers for system tables are defined. Segments for those sy...">AK_init_system_catalog()</a> to initialize disk manager. It also calls AK_allocate_array_currently_accessed_blocks() to allocate memory needed for thread-safe reading and writing to disk. </dd></dl>

</div>
</div>
<a class="anchor" id="af99cdc5c8456ad5ff87fb542d030c4d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_init_system_catalog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function initializes the system catalog. Headers for system tables are defined. Segments for those system tables are allocated. Above function <a class="el" href="dbman_8c.html#af4c050534ddf6dcf1cba09987424ff76" title="Function that registers system tables. Block at the given address is read. Various data from function...">AK_register_system_tables()</a> to register system tables. </p>
<dl class="section author"><dt>Author</dt><dd>Miroslav Policki </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the system catalog has been successfully initialized, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ac48430852cddc2cc7b79dd2775212b10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_init_system_tables_catalog </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>function_arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trigger_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>db_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraintNull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraintCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraintUnique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function initialises the sytem table catalog and writes the result in first (0) block in db_file. Catalog block, catalog header name, catalog header address are allocated. Address, type, chained_with and AK_free_space attributes are initialized. Names of various database elements are written in block. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>address of system table of relation in db_file </td></tr>
    <tr><td class="paramname">attribute</td><td>address of system table of attribute in db_file </td></tr>
    <tr><td class="paramname">index</td><td>address of system table of index in db_file </td></tr>
    <tr><td class="paramname">view</td><td>address of system table of view in db_file </td></tr>
    <tr><td class="paramname">sequence</td><td>address of system table of sequence in db_file </td></tr>
    <tr><td class="paramname">function</td><td>address of system table of function in db_file </td></tr>
    <tr><td class="paramname">function_arguments</td><td>address of system table of function_arguments in db_file </td></tr>
    <tr><td class="paramname">trigger</td><td>address of system table of trigger in db_file </td></tr>
    <tr><td class="paramname">trigger_conditions</td><td>address of system table of trigger_conditions in db_file </td></tr>
    <tr><td class="paramname">db</td><td>address of system table of db in db_file </td></tr>
    <tr><td class="paramname">db_obj</td><td>address of system table of db_obj in db_file </td></tr>
    <tr><td class="paramname">user</td><td>address of system table of user in db_file </td></tr>
    <tr><td class="paramname">group</td><td>address of system table of group in db_file </td></tr>
    <tr><td class="paramname">user_group</td><td>address of system table of users associated with groups in db_file </td></tr>
    <tr><td class="paramname">user_right</td><td>address of system table of user right in db_file </td></tr>
    <tr><td class="paramname">group_right</td><td>address of system table of group right in db_file </td></tr>
    <tr><td class="paramname">constraint</td><td>address of system table of constraint in db_file </td></tr>
    <tr><td class="paramname">constraintNull</td><td>address of system table of constraintNull in db_file </td></tr>
    <tr><td class="paramname">constraintCheck</td><td>system table address for check constraint </td></tr>
    <tr><td class="paramname">reference</td><td>address of system table of reference in db_file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if initialization was succesful if not returns EXIT_ERROR </dd></dl>
<p>first header attribute of catalog_block</p>
<p>second attribute of catalog_block</p>
<p>initialize other elements of block (adress, type, chained_with, AK_free_space)</p>
<p>using as an address for the first AK_free space in block-&gt;data</p>
<p>merge catalog_heder with heders created before</p>
<p>insert data and tuple_dict in block</p>
<p>call function for writing the block on the first place in the file (ie. first block is on position zero) </p>

</div>
</div>
<a class="anchor" id="a0f011234546a9f1cc751a0d08036b131"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_insert_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td>
          <td class="paramname"><em>block_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>entry_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for inserting entry in tuple_dict and data of a block. Address, type and size of catalog_tuple_dict are set. Free space of block is also set. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_adress</td><td>adress of a block in which we want insert data </td></tr>
    <tr><td class="paramname">type</td><td>type of entry_data </td></tr>
    <tr><td class="paramname">entry_data</td><td>(char) data which is inserted, can be int but must first be converted to char </td></tr>
    <tr><td class="paramname">i</td><td>(int) adress in tuple_dict array (example block_address-&gt;tuple_dict[i]) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value because it gets the address of an block like a function parameter and works directly with the orginal block </dd></dl>
<p>using strlen becuse sizeof(entry_data) is always 4 copy data into bloc-&gt;data on start position bloc-&gt;AK_free_space</p>
<p>address of entry data in block-&gt;data</p>
<p>calculate next AK_free space for the next entry data </p><pre class="fragment">                                                              sizeof(entry_data)+1);///(sizeof(int));
</pre><p> no need for "+strlen(entry_data)" while "+1" is like "new line"</p>
<p>type of entry data</p>
<p>size of entry data</p>
<p>copy tuple_dict to block-&gt;tuple_dict[i] must use &amp; becouse tuple_dict[i] is value and catalog_tuple_dict adress </p>

</div>
</div>
<a class="anchor" id="a3157bc3da79c19192a915acc1235bad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_memset_int </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that sets the first num ints of a block of memory to the specified value. </p>
<dl class="section author"><dt>Author</dt><dd>Miroslav Policki </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>pointer to the block of memory to fill </td></tr>
    <tr><td class="paramname">value</td><td>int value to be set </td></tr>
    <tr><td class="paramname">num</td><td>number of ints in the block of memory to be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
<a class="anchor" id="a1ff7d6ea92a45cda91ff2063043900a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_new_extent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>old_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extent_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function alocates new extent of blocks. If argument "old_size" is 0 than size of extent is INITIAL_EXTENT_SIZE. Otherwise, resize factor is set according to type of extent. If writing of block is successful, number of blocks is incremented. </p>
<dl class="section author"><dt>Author</dt><dd>Nikola Bakoš, updated by Dino Laktašiæ (fixed header BUG), refurbished by dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_address</td><td>address (block number) to start searching for sufficient space </td></tr>
    <tr><td class="paramname">old_size</td><td>size of previous extent in same segment (in blocks) </td></tr>
    <tr><td class="paramname">extent_type</td><td>type of extent (can be one of: SEGMENT_TYPE_SYSTEM_TABLE, SEGMENT_TYPE_TABLE, SEGMENT_TYPE_INDEX, SEGMENT_TYPE_TRANSACTION, SEGMENT_TYPE_TEMP </td></tr>
    <tr><td class="paramname">header</td><td>pointer to header that should be written to the new extent (all blocks) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address (block number) of new extent if successful, EXIT_ERROR otherwise </dd></dl>
<p>var - How much of space is required for extent</p>
<p>vars for loop [for]</p>
<p>if the old_size is 0 then the size of new extent is INITIAL_EXTENT_SIZE</p>
<p>if some blocks are not succesfully allocated, which means that the extend allocation has FAILED </p>

</div>
</div>
<a class="anchor" id="a79e7998e69e2910528f7ef258469b2be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_new_segment </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that allocates new segment of extents. In this phase of implementation, only extents containing INITIAL_EXTENT_SIZE blocks can be allocated. If extent is successfully allocated, number of allocated extents is incremented and function goes to next block after allocated extent. Otherwise, function moves to INITIAL_EXTENT_SIZE blocks. In that way function gets either first block of new extent or some block in that extent which will not be AK_free. </p>
<dl class="section author"><dt>Author</dt><dd>Tomislav Fotak, refurbished by dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>(character pointer) name of segment </td></tr>
    <tr><td class="paramname">type</td><td>segment type (possible values: SEGMENT_TYPE_SYSTEM_TABLE, SEGMENT_TYPE_TABLE, SEGMENT_TYPE_INDEX, SEGMENT_TYPE_TRANSACTION, SEGMENT_TYPE_TEMP) </td></tr>
    <tr><td class="paramname">header</td><td>(header pointer) pointer to header that should be written to the new extent (all blocks) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS for success or EXIT_ERROR if some error occurs </dd></dl>
<p>start address for segment because we can not allocate segment in block 0 </p>

</div>
</div>
<a class="anchor" id="a3fcca519b1dbe309c683d64b0e955dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_print_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>gg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fpp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that dumps block. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>nothing </dd></dl>

</div>
</div>
<a class="anchor" id="a2c880db7cf4f8332ae7e93c6b71cc911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAK__block.html">AK_block</a>* AK_read_block </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that reads a block at a given address (block number less than db_file_size). New block is allocated. Database file is opened. Position is set to provided address block. At the end function reads file from that position. Completely thread-safe. </p>
<dl class="section author"><dt>Author</dt><dd>Markus Schatten, updated dv and Domagoj Šitum (thread-safe enabled) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>block number (address) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to block allocated in memory </dd></dl>

</div>
</div>
<a class="anchor" id="a5499694bd97b104560d14ef70abe2c73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* AK_read_block_for_testing </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is only for testing. It has to be there, because pthread_create only accepts void* function_name (void *) function format. So AK_read_block is no-go for pthread_create. </p>
<dl class="section author"><dt>Author</dt><dd>Domagoj Šitum </dd></dl>

</div>
</div>
<a class="anchor" id="af4c050534ddf6dcf1cba09987424ff76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_register_system_tables </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>function_arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trigger_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>db_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraintNull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraintCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraintUnique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that registers system tables. Block at the given address is read. Various data from function arguments are written in block about different database elements. </p>
<dl class="section author"><dt>Author</dt><dd>Unknown </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>relation in database </td></tr>
    <tr><td class="paramname">attribute</td><td>attribute in databse </td></tr>
    <tr><td class="paramname">index</td><td>index in database </td></tr>
    <tr><td class="paramname">view</td><td>view in database </td></tr>
    <tr><td class="paramname">sequence</td><td>sequence in database </td></tr>
    <tr><td class="paramname">function</td><td>function in database </td></tr>
    <tr><td class="paramname">function_arguments</td><td>functional_arguments in databse </td></tr>
    <tr><td class="paramname">trigger</td><td>trigger in database </td></tr>
    <tr><td class="paramname">trigger_conditions</td><td>trigger conditions in databse </td></tr>
    <tr><td class="paramname">db</td><td>database </td></tr>
    <tr><td class="paramname">db_obj</td><td>database object </td></tr>
    <tr><td class="paramname">user</td><td>user in database </td></tr>
    <tr><td class="paramname">group</td><td>group in database </td></tr>
    <tr><td class="paramname">user_group</td><td>user associated with group in database </td></tr>
    <tr><td class="paramname">user_right</td><td>user right in database </td></tr>
    <tr><td class="paramname">group_right</td><td>group right in database </td></tr>
    <tr><td class="paramname">constraint</td><td>constraint in database </td></tr>
    <tr><td class="paramname">constraintNull</td><td>Null constraint in database </td></tr>
    <tr><td class="paramname">constraintCheck</td><td>Check constraint in database </td></tr>
    <tr><td class="paramname">reference</td><td>reference database </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="a41ad69e55d09ab4aa2bec6dd34805367"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_thread_safe_block_access_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests thread safe reading and writing to blocks. There is N writing and N reading threads, which are going through iterations. Each reading thread should read the data (character) that was set by last writing thread. </p>
<dl class="section author"><dt>Author</dt><dd>Domagoj Šitum </dd></dl>

</div>
</div>
<a class="anchor" id="a222ea31aa276d52e464137a3b144f78a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_write_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function writes a block to DB file. Database file is opened. Position is set to provided address block. Block is written to provided address. Completely thread-safe. </p>
<dl class="section author"><dt>Author</dt><dd>Markus Schatten, updated by Domagoj Šitum (thread-safe enabled) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>poiner to block allocated in memory to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if successful, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a0558e034eeed865a1c855de5cfad20ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* AK_write_block_for_testing </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is only for testing. It has to be there, because pthread_create only accepts void* function_name (void *) function format. So AK_write_block is no-go for pthread_create. </p>
<dl class="section author"><dt>Author</dt><dd>Domagoj Šitum </dd></dl>

</div>
</div>
<a class="anchor" id="adbc6978517271fbd48a004cb039ac6c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fsize </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to determine file size. </p>
<dl class="section return"><dt>Returns</dt><dd>file size </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
