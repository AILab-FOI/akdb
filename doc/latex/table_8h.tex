\hypertarget{table_8h}{}\section{file/table.h File Reference}
\label{table_8h}\index{file/table.\+h@{file/table.\+h}}
{\ttfamily \#include \char`\"{}../mm/memoman.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}../auxi/mempro.\+h\char`\"{}}\\*
{\ttfamily \#include $<$time.\+h$>$}\\*
Include dependency graph for table.\+h\+:
% FIG 0
This graph shows which files directly or indirectly include this file\+:
% FIG 1
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structAK__create__table__struct}{A\+K\+\_\+create\+\_\+table\+\_\+struct}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structAK__create__table__struct}{A\+K\+\_\+create\+\_\+table\+\_\+struct} {\bfseries A\+K\+\_\+create\+\_\+table\+\_\+parameter}\hypertarget{table_8h_a9ffcfed3224448f95a8527175a663713}{}\label{table_8h_a9ffcfed3224448f95a8527175a663713}

\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structAK__create__table__struct}{A\+K\+\_\+create\+\_\+table\+\_\+parameter} $\ast$ {\bfseries A\+K\+\_\+create\+\_\+create\+\_\+table\+\_\+parameter} (int type, char $\ast$name)\hypertarget{table_8h_a8a04c96bbf75ce1b44806086089a4f4d}{}\label{table_8h_a8a04c96bbf75ce1b44806086089a4f4d}

\item 
void {\bfseries A\+K\+\_\+create\+\_\+table} (char $\ast$tbl\+Name, \hyperlink{structAK__create__table__struct}{A\+K\+\_\+create\+\_\+table\+\_\+parameter} $\ast$parameters, int attribute\+\_\+count)\hypertarget{table_8h_a2e945ec62d81d37bc64bcf2e51fbf14c}{}\label{table_8h_a2e945ec62d81d37bc64bcf2e51fbf14c}

\item 
int \hyperlink{table_8h_a20d2468a09018e2a8609da759e428a41}{A\+K\+\_\+num\+\_\+attr} (char $\ast$tbl\+Name)
\begin{DoxyCompactList}\small\item\em Determine the number of attributes in the table. \end{DoxyCompactList}\item 
int \hyperlink{table_8h_af39c8534193d3dd1674c19d98dc4be50}{A\+K\+\_\+get\+\_\+num\+\_\+records} (char $\ast$tbl\+Name)
\begin{DoxyCompactList}\small\item\em Determine number of rows in the table. \end{DoxyCompactList}\item 
\hyperlink{structAK__header}{A\+K\+\_\+header} $\ast$ \hyperlink{table_8h_ab063278b908f59ec216c7f762601e13a}{A\+K\+\_\+get\+\_\+header} (char $\ast$tbl\+Name)
\begin{DoxyCompactList}\small\item\em Function that getts table header. \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{table_8h_a39e6119390a5100ba21800098e18fffa}{A\+K\+\_\+get\+\_\+attr\+\_\+name} (char $\ast$tbl\+Name, int index)
\begin{DoxyCompactList}\small\item\em Function that gets attribute name for some zero-\/based index. \end{DoxyCompactList}\item 
int \hyperlink{table_8h_a8c7ec38cebacb8c47b7e1ea572efa6bd}{A\+K\+\_\+get\+\_\+attr\+\_\+index} (char $\ast$tbl\+Name, char $\ast$attr\+Name)
\begin{DoxyCompactList}\small\item\em Function that gets zero-\/based index for atrribute. \end{DoxyCompactList}\item 
struct list\+\_\+node $\ast$ \hyperlink{table_8h_a22093cf8d0a2e9f96f068fcea7547ea7}{A\+K\+\_\+get\+\_\+column} (int num, char $\ast$tbl\+Name)
\begin{DoxyCompactList}\small\item\em Function that gets all values in some column and put on the list. \end{DoxyCompactList}\item 
struct list\+\_\+node $\ast$ \hyperlink{table_8h_a23c35e11cdc86e34b2252aab918866ec}{A\+K\+\_\+get\+\_\+row} (int num, char $\ast$tbl\+Name)
\begin{DoxyCompactList}\small\item\em Function that gets all values in some row and put on the list. \end{DoxyCompactList}\item 
struct list\+\_\+node $\ast$ \hyperlink{table_8h_aa00d9459b5fd8549a6321cb7dae1cd96}{A\+K\+\_\+get\+\_\+tuple} (int row, int column, char $\ast$tbl\+Name)
\begin{DoxyCompactList}\small\item\em Function that gets value in some row and column. \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{table_8h_a1364e5d1a774d82e11537323714149b7}{A\+K\+\_\+tuple\+\_\+to\+\_\+string} (struct list\+\_\+node $\ast$tuple)
\begin{DoxyCompactList}\small\item\em Function that converts tuple value to string. \end{DoxyCompactList}\item 
void \hyperlink{table_8h_a8d27c7ece5bd1e8e05f072e7d0b7931e}{A\+K\+\_\+print\+\_\+row\+\_\+spacer} (int col\+\_\+len\mbox{[}$\,$\mbox{]}, int length)
\begin{DoxyCompactList}\small\item\em Function that prints row spacer. \end{DoxyCompactList}\item 
void \hyperlink{table_8h_ae9b9e240944e538438c1298e224d9fe3}{A\+K\+\_\+print\+\_\+row} (int col\+\_\+len\mbox{[}$\,$\mbox{]}, struct list\+\_\+node $\ast$row)
\begin{DoxyCompactList}\small\item\em Function that prints table row. \end{DoxyCompactList}\item 
void \hyperlink{table_8h_a5d441d5b03e8a0b7fbcbd39122a6b70f}{A\+K\+\_\+print\+\_\+table} (char $\ast$tbl\+Name)
\begin{DoxyCompactList}\small\item\em Function for printing table. \end{DoxyCompactList}\item 
void \hyperlink{table_8h_a05a6f3bd52b21adb13d8deb2131b148a}{A\+K\+\_\+print\+\_\+row\+\_\+spacer\+\_\+to\+\_\+file} (int col\+\_\+len\mbox{[}$\,$\mbox{]}, int length)
\begin{DoxyCompactList}\small\item\em Function that prints row spacer update by Luka Rajcevic. \end{DoxyCompactList}\item 
void \hyperlink{table_8h_ac3a161df90c3cbedb222d2bff9e63c6a}{A\+K\+\_\+print\+\_\+row\+\_\+to\+\_\+file} (int col\+\_\+len\mbox{[}$\,$\mbox{]}, struct list\+\_\+node $\ast$row)
\begin{DoxyCompactList}\small\item\em Function that prints table row update by Luka Rajcevic. \end{DoxyCompactList}\item 
void \hyperlink{table_8h_aba95d749268e4310eedfeb71037e1147}{A\+K\+\_\+print\+\_\+table\+\_\+to\+\_\+file} (char $\ast$tbl\+Name)
\begin{DoxyCompactList}\small\item\em Function for printing table. \end{DoxyCompactList}\item 
int \hyperlink{table_8h_acddbb862c04235d408075c351cd68a59}{A\+K\+\_\+table\+\_\+empty} (char $\ast$tbl\+Name)
\begin{DoxyCompactList}\small\item\em Function that check whether table is empty. \end{DoxyCompactList}\item 
int \hyperlink{table_8h_a8b329f1d9df542f2c2b51ea9d12955c7}{A\+K\+\_\+get\+\_\+table\+\_\+obj\+\_\+id} (char $\ast$table)
\begin{DoxyCompactList}\small\item\em Function that gets obj\+\_\+id of named table from A\+K\+\_\+relation system table. \end{DoxyCompactList}\item 
int \hyperlink{table_8h_ac88167526b2df0856feee63ec7cf84e0}{A\+K\+\_\+check\+\_\+tables\+\_\+scheme} (\hyperlink{structAK__mem__block}{A\+K\+\_\+mem\+\_\+block} $\ast$tbl1\+\_\+temp\+\_\+block, \hyperlink{structAK__mem__block}{A\+K\+\_\+mem\+\_\+block} $\ast$tbl2\+\_\+temp\+\_\+block, char $\ast$operator\+\_\+name)
\begin{DoxyCompactList}\small\item\em Function to check if tables have the same relation schema. \end{DoxyCompactList}\item 
char $\ast$ {\bfseries get\+\_\+row\+\_\+attr\+\_\+data} ()\hypertarget{table_8h_aaf4049b7b8d241ad828e5166640d6d62}{}\label{table_8h_aaf4049b7b8d241ad828e5166640d6d62}

\item 
struct list\+\_\+node $\ast$ {\bfseries A\+K\+\_\+get\+\_\+table\+\_\+row} (int num, char $\ast$tbl\+Name)\hypertarget{table_8h_a7a0ce05eed00d4962f48c079efa8fde6}{}\label{table_8h_a7a0ce05eed00d4962f48c079efa8fde6}

\item 
void \hyperlink{table_8h_a90a0fc1f502e0dcecffa983af7ec2019}{A\+K\+\_\+table\+\_\+test} ()
\begin{DoxyCompactList}\small\item\em Function for testing table abstraction. \end{DoxyCompactList}\item 
int \hyperlink{table_8h_a7c72abd64691fabe0326bfb0a4a7e187}{A\+K\+\_\+rename} (char $\ast$old\+\_\+table\+\_\+name, char $\ast$old\+\_\+attr, char $\ast$new\+\_\+table\+\_\+name, char $\ast$new\+\_\+attr)
\begin{DoxyCompactList}\small\item\em Function for renaming table and/or attribute in table (moved from rename.\+c) \end{DoxyCompactList}\item 
void \hyperlink{table_8h_ad79d22868393b19077efe8bc5b2f6935}{A\+K\+\_\+op\+\_\+rename\+\_\+test} ()
\begin{DoxyCompactList}\small\item\em Function for rename operator testing (moved from rename.\+c) \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Header file that provides data structures for table abstraction

This program is free software; you can redistribute it and/or modify it under the terms of the G\+NU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but W\+I\+T\+H\+O\+UT A\+NY W\+A\+R\+R\+A\+N\+TY; without even the implied warranty of M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY or F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE. See the G\+NU Library General Public License for more details.

You should have received a copy of the G\+NU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-\/1301, U\+SA 

\subsection{Function Documentation}
\index{table.\+h@{table.\+h}!A\+K\+\_\+check\+\_\+tables\+\_\+scheme@{A\+K\+\_\+check\+\_\+tables\+\_\+scheme}}
\index{A\+K\+\_\+check\+\_\+tables\+\_\+scheme@{A\+K\+\_\+check\+\_\+tables\+\_\+scheme}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+check\+\_\+tables\+\_\+scheme(\+A\+K\+\_\+mem\+\_\+block $\ast$tbl1\+\_\+temp\+\_\+block, A\+K\+\_\+mem\+\_\+block $\ast$tbl2\+\_\+temp\+\_\+block, char $\ast$operator\+\_\+name)}{AK_check_tables_scheme(AK_mem_block *tbl1_temp_block, AK_mem_block *tbl2_temp_block, char *operator_name)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+check\+\_\+tables\+\_\+scheme (
\begin{DoxyParamCaption}
\item[{{\bf A\+K\+\_\+mem\+\_\+block} $\ast$}]{tbl1\+\_\+temp\+\_\+block, }
\item[{{\bf A\+K\+\_\+mem\+\_\+block} $\ast$}]{tbl2\+\_\+temp\+\_\+block, }
\item[{char $\ast$}]{operator\+\_\+name}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_ac88167526b2df0856feee63ec7cf84e0}{}\label{table_8h_ac88167526b2df0856feee63ec7cf84e0}


Function to check if tables have the same relation schema. 

\begin{DoxyAuthor}{Author}
Dino Laktašić, abstracted from \hyperlink{difference_8c}{difference.\+c} for use in \hyperlink{difference_8c}{difference.\+c}, \hyperlink{intersect_8c}{intersect.\+c} and \hyperlink{union_8c}{union.\+c} by Tomislav Mikulček 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em tbl1\+\_\+temp\+\_\+block} & first cache block of the first table \\
\hline
{\em tbl2\+\_\+temp\+\_\+block} & first cache block of the second table \\
\hline
{\em operator\+\_\+name} & the name of operator, used for displaying error message \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
if success returns num of attributes in schema, else returns E\+X\+I\+T\+\_\+\+E\+R\+R\+OR 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+get\+\_\+attr\+\_\+index@{A\+K\+\_\+get\+\_\+attr\+\_\+index}}
\index{A\+K\+\_\+get\+\_\+attr\+\_\+index@{A\+K\+\_\+get\+\_\+attr\+\_\+index}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+get\+\_\+attr\+\_\+index(char $\ast$tbl\+Name, char $\ast$attr\+Name)}{AK_get_attr_index(char *tblName, char *attrName)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+get\+\_\+attr\+\_\+index (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{tbl\+Name, }
\item[{char $\ast$}]{attr\+Name}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_a8c7ec38cebacb8c47b7e1ea572efa6bd}{}\label{table_8h_a8c7ec38cebacb8c47b7e1ea572efa6bd}


Function that gets zero-\/based index for atrribute. 

\begin{DoxyAuthor}{Author}
Matija Šestak. 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em $\ast$tbl\+Name} & table name \\
\hline
{\em $\ast$attr\+Name} & attribute name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
zero-\/based index 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+get\+\_\+attr\+\_\+name@{A\+K\+\_\+get\+\_\+attr\+\_\+name}}
\index{A\+K\+\_\+get\+\_\+attr\+\_\+name@{A\+K\+\_\+get\+\_\+attr\+\_\+name}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+get\+\_\+attr\+\_\+name(char $\ast$tbl\+Name, int index)}{AK_get_attr_name(char *tblName, int index)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ A\+K\+\_\+get\+\_\+attr\+\_\+name (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{tbl\+Name, }
\item[{int}]{index}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_a39e6119390a5100ba21800098e18fffa}{}\label{table_8h_a39e6119390a5100ba21800098e18fffa}


Function that gets attribute name for some zero-\/based index. 

\begin{DoxyAuthor}{Author}
Matija Šestak. 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em $\ast$tbl\+Name} & table name \\
\hline
{\em index} & zero-\/based index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
attribute name 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+get\+\_\+column@{A\+K\+\_\+get\+\_\+column}}
\index{A\+K\+\_\+get\+\_\+column@{A\+K\+\_\+get\+\_\+column}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+get\+\_\+column(int num, char $\ast$tbl\+Name)}{AK_get_column(int num, char *tblName)}}]{\setlength{\rightskip}{0pt plus 5cm}struct list\+\_\+node$\ast$ A\+K\+\_\+get\+\_\+column (
\begin{DoxyParamCaption}
\item[{int}]{num, }
\item[{char $\ast$}]{tbl\+Name}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_a22093cf8d0a2e9f96f068fcea7547ea7}{}\label{table_8h_a22093cf8d0a2e9f96f068fcea7547ea7}


Function that gets all values in some column and put on the list. 

\begin{DoxyAuthor}{Author}
Matija Šestak. 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em num} & zero-\/based column index \\
\hline
{\em $\ast$tbl\+Name} & table name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
column values list 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+get\+\_\+header@{A\+K\+\_\+get\+\_\+header}}
\index{A\+K\+\_\+get\+\_\+header@{A\+K\+\_\+get\+\_\+header}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+get\+\_\+header(char $\ast$tbl\+Name)}{AK_get_header(char *tblName)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf A\+K\+\_\+header}$\ast$ A\+K\+\_\+get\+\_\+header (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{tbl\+Name}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_ab063278b908f59ec216c7f762601e13a}{}\label{table_8h_ab063278b908f59ec216c7f762601e13a}


Function that getts table header. 

\begin{DoxyAuthor}{Author}
Matija Šestak. 
\begin{DoxyEnumerate}
\item Read addresses of extents 
\item If there is no extents in the table, return -\/1 
\item else read the first block 
\item allocate array 
\item copy table header to the array 
\end{DoxyEnumerate}
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em $\ast$tbl\+Name} & table name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
array of table header 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+get\+\_\+num\+\_\+records@{A\+K\+\_\+get\+\_\+num\+\_\+records}}
\index{A\+K\+\_\+get\+\_\+num\+\_\+records@{A\+K\+\_\+get\+\_\+num\+\_\+records}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+get\+\_\+num\+\_\+records(char $\ast$tbl\+Name)}{AK_get_num_records(char *tblName)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+get\+\_\+num\+\_\+records (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{tbl\+Name}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_af39c8534193d3dd1674c19d98dc4be50}{}\label{table_8h_af39c8534193d3dd1674c19d98dc4be50}


Determine number of rows in the table. 

\begin{DoxyAuthor}{Author}
Matija Šestak. 
\begin{DoxyEnumerate}
\item Read addresses of extents 
\item If there is no extents in the table, return -\/1 
\item For each extent from table 
\item For each block in the extent 
\item Get a block 
\item Exit if there is no records in block 
\item Count tuples in block 
\item Return the number of tuples divided by number of attributes 
\end{DoxyEnumerate}
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em $\ast$table\+Name} & table name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of rows in the table 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+get\+\_\+row@{A\+K\+\_\+get\+\_\+row}}
\index{A\+K\+\_\+get\+\_\+row@{A\+K\+\_\+get\+\_\+row}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+get\+\_\+row(int num, char $\ast$tbl\+Name)}{AK_get_row(int num, char *tblName)}}]{\setlength{\rightskip}{0pt plus 5cm}struct list\+\_\+node$\ast$ A\+K\+\_\+get\+\_\+row (
\begin{DoxyParamCaption}
\item[{int}]{num, }
\item[{char $\ast$}]{tbl\+Name}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_a23c35e11cdc86e34b2252aab918866ec}{}\label{table_8h_a23c35e11cdc86e34b2252aab918866ec}


Function that gets all values in some row and put on the list. 

\begin{DoxyAuthor}{Author}
Markus Schatten, Matija Šestak. 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em num} & zero-\/based row index \\
\hline
{\em $\ast$} & tbl\+Name table name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
row values list 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+get\+\_\+table\+\_\+obj\+\_\+id@{A\+K\+\_\+get\+\_\+table\+\_\+obj\+\_\+id}}
\index{A\+K\+\_\+get\+\_\+table\+\_\+obj\+\_\+id@{A\+K\+\_\+get\+\_\+table\+\_\+obj\+\_\+id}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+get\+\_\+table\+\_\+obj\+\_\+id(char $\ast$table)}{AK_get_table_obj_id(char *table)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+get\+\_\+table\+\_\+obj\+\_\+id (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{table}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_a8b329f1d9df542f2c2b51ea9d12955c7}{}\label{table_8h_a8b329f1d9df542f2c2b51ea9d12955c7}


Function that gets obj\+\_\+id of named table from A\+K\+\_\+relation system table. 

\begin{DoxyAuthor}{Author}
Dejan Frankovic 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em $\ast$table} & table name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
obj\+\_\+id of the table or E\+X\+I\+T\+\_\+\+E\+R\+R\+OR if there is no table with that name 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+get\+\_\+tuple@{A\+K\+\_\+get\+\_\+tuple}}
\index{A\+K\+\_\+get\+\_\+tuple@{A\+K\+\_\+get\+\_\+tuple}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+get\+\_\+tuple(int row, int column, char $\ast$tbl\+Name)}{AK_get_tuple(int row, int column, char *tblName)}}]{\setlength{\rightskip}{0pt plus 5cm}struct list\+\_\+node$\ast$ A\+K\+\_\+get\+\_\+tuple (
\begin{DoxyParamCaption}
\item[{int}]{row, }
\item[{int}]{column, }
\item[{char $\ast$}]{tbl\+Name}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_aa00d9459b5fd8549a6321cb7dae1cd96}{}\label{table_8h_aa00d9459b5fd8549a6321cb7dae1cd96}


Function that gets value in some row and column. 

\begin{DoxyAuthor}{Author}
Matija Šestak. 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em row} & zero-\/based row index \\
\hline
{\em column} & zero-\/based column index \\
\hline
{\em $\ast$tbl\+Name} & table name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
value in the list 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+num\+\_\+attr@{A\+K\+\_\+num\+\_\+attr}}
\index{A\+K\+\_\+num\+\_\+attr@{A\+K\+\_\+num\+\_\+attr}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+num\+\_\+attr(char $\ast$tbl\+Name)}{AK_num_attr(char *tblName)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+num\+\_\+attr (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{tbl\+Name}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_a20d2468a09018e2a8609da759e428a41}{}\label{table_8h_a20d2468a09018e2a8609da759e428a41}


Determine the number of attributes in the table. 

\begin{DoxyAuthor}{Author}
Matija Šestak. 
\begin{DoxyEnumerate}
\item Read addresses of extents 
\item If there is no extents in the table, return -\/1 
\item else read the first block 
\item while header tuple exists in the block, increment num\+\_\+attr 
\end{DoxyEnumerate}
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em $\ast$} & tbl\+Name table name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of attributes in the table 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+op\+\_\+rename\+\_\+test@{A\+K\+\_\+op\+\_\+rename\+\_\+test}}
\index{A\+K\+\_\+op\+\_\+rename\+\_\+test@{A\+K\+\_\+op\+\_\+rename\+\_\+test}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+op\+\_\+rename\+\_\+test()}{AK_op_rename_test()}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+op\+\_\+rename\+\_\+test (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_ad79d22868393b19077efe8bc5b2f6935}{}\label{table_8h_ad79d22868393b19077efe8bc5b2f6935}


Function for rename operator testing (moved from rename.\+c) 

\begin{DoxyAuthor}{Author}
Mislav Čakarić, edited by Ljubo Barać 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
No return value 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+print\+\_\+row@{A\+K\+\_\+print\+\_\+row}}
\index{A\+K\+\_\+print\+\_\+row@{A\+K\+\_\+print\+\_\+row}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+print\+\_\+row(int col\+\_\+len[], struct list\+\_\+node $\ast$row)}{AK_print_row(int col_len[], struct list_node *row)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+print\+\_\+row (
\begin{DoxyParamCaption}
\item[{int}]{col\+\_\+len\mbox{[}$\,$\mbox{]}, }
\item[{struct list\+\_\+node $\ast$}]{row}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_ae9b9e240944e538438c1298e224d9fe3}{}\label{table_8h_ae9b9e240944e538438c1298e224d9fe3}


Function that prints table row. 

\begin{DoxyAuthor}{Author}
Dino Laktašić 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em col\+\_\+len\mbox{[}$\,$\mbox{]}} & array of max lengths for each attribute \\
\hline
{\em $\ast$row} & list with row elements \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
No return value 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+print\+\_\+row\+\_\+spacer@{A\+K\+\_\+print\+\_\+row\+\_\+spacer}}
\index{A\+K\+\_\+print\+\_\+row\+\_\+spacer@{A\+K\+\_\+print\+\_\+row\+\_\+spacer}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+print\+\_\+row\+\_\+spacer(int col\+\_\+len[], int length)}{AK_print_row_spacer(int col_len[], int length)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+print\+\_\+row\+\_\+spacer (
\begin{DoxyParamCaption}
\item[{int}]{col\+\_\+len\mbox{[}$\,$\mbox{]}, }
\item[{int}]{length}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_a8d27c7ece5bd1e8e05f072e7d0b7931e}{}\label{table_8h_a8d27c7ece5bd1e8e05f072e7d0b7931e}


Function that prints row spacer. 

\begin{DoxyAuthor}{Author}
Dino Laktašić. 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em col\+\_\+len\mbox{[}$\,$\mbox{]}} & max lengths for each attribute cell \\
\hline
{\em length} & total table width \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
printed row spacer 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+print\+\_\+row\+\_\+spacer\+\_\+to\+\_\+file@{A\+K\+\_\+print\+\_\+row\+\_\+spacer\+\_\+to\+\_\+file}}
\index{A\+K\+\_\+print\+\_\+row\+\_\+spacer\+\_\+to\+\_\+file@{A\+K\+\_\+print\+\_\+row\+\_\+spacer\+\_\+to\+\_\+file}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+print\+\_\+row\+\_\+spacer\+\_\+to\+\_\+file(int col\+\_\+len[], int length)}{AK_print_row_spacer_to_file(int col_len[], int length)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+print\+\_\+row\+\_\+spacer\+\_\+to\+\_\+file (
\begin{DoxyParamCaption}
\item[{int}]{col\+\_\+len\mbox{[}$\,$\mbox{]}, }
\item[{int}]{length}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_a05a6f3bd52b21adb13d8deb2131b148a}{}\label{table_8h_a05a6f3bd52b21adb13d8deb2131b148a}


Function that prints row spacer update by Luka Rajcevic. 

\begin{DoxyAuthor}{Author}
Dino Laktašić. 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em col\+\_\+len\mbox{[}$\,$\mbox{]}} & max lengths for each attribute cell \\
\hline
{\em length} & total table width \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
printed row spacer 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+print\+\_\+row\+\_\+to\+\_\+file@{A\+K\+\_\+print\+\_\+row\+\_\+to\+\_\+file}}
\index{A\+K\+\_\+print\+\_\+row\+\_\+to\+\_\+file@{A\+K\+\_\+print\+\_\+row\+\_\+to\+\_\+file}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+print\+\_\+row\+\_\+to\+\_\+file(int col\+\_\+len[], struct list\+\_\+node $\ast$row)}{AK_print_row_to_file(int col_len[], struct list_node *row)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+print\+\_\+row\+\_\+to\+\_\+file (
\begin{DoxyParamCaption}
\item[{int}]{col\+\_\+len\mbox{[}$\,$\mbox{]}, }
\item[{struct list\+\_\+node $\ast$}]{row}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_ac3a161df90c3cbedb222d2bff9e63c6a}{}\label{table_8h_ac3a161df90c3cbedb222d2bff9e63c6a}


Function that prints table row update by Luka Rajcevic. 

\begin{DoxyAuthor}{Author}
Dino Laktašić 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em col\+\_\+len\mbox{[}$\,$\mbox{]}} & array of max lengths for each attribute \\
\hline
{\em $\ast$row} & list with row elements \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
No return value 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+print\+\_\+table@{A\+K\+\_\+print\+\_\+table}}
\index{A\+K\+\_\+print\+\_\+table@{A\+K\+\_\+print\+\_\+table}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+print\+\_\+table(char $\ast$tbl\+Name)}{AK_print_table(char *tblName)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+print\+\_\+table (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{tbl\+Name}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_a5d441d5b03e8a0b7fbcbd39122a6b70f}{}\label{table_8h_a5d441d5b03e8a0b7fbcbd39122a6b70f}


Function for printing table. 

\begin{DoxyAuthor}{Author}
Dino Laktašić and Mislav Čakarić (replaced old print table function by new one) 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em $\ast$tbl\+Name} & table name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
No return value 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+print\+\_\+table\+\_\+to\+\_\+file@{A\+K\+\_\+print\+\_\+table\+\_\+to\+\_\+file}}
\index{A\+K\+\_\+print\+\_\+table\+\_\+to\+\_\+file@{A\+K\+\_\+print\+\_\+table\+\_\+to\+\_\+file}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+print\+\_\+table\+\_\+to\+\_\+file(char $\ast$tbl\+Name)}{AK_print_table_to_file(char *tblName)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+print\+\_\+table\+\_\+to\+\_\+file (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{tbl\+Name}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_aba95d749268e4310eedfeb71037e1147}{}\label{table_8h_aba95d749268e4310eedfeb71037e1147}


Function for printing table. 

\begin{DoxyAuthor}{Author}
Dino Laktašić and Mislav Čakarić (replaced old print table function by new one) update by Luka Rajcevic 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em $\ast$tbl\+Name} & table name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
No return value update by Anto Tomaš (corrected the Ak\+\_\+\+Delete\+All\+\_\+\+L3 function) 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+rename@{A\+K\+\_\+rename}}
\index{A\+K\+\_\+rename@{A\+K\+\_\+rename}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+rename(char $\ast$old\+\_\+table\+\_\+name, char $\ast$old\+\_\+attr, char $\ast$new\+\_\+table\+\_\+name, char $\ast$new\+\_\+attr)}{AK_rename(char *old_table_name, char *old_attr, char *new_table_name, char *new_attr)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+rename (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{old\+\_\+table\+\_\+name, }
\item[{char $\ast$}]{old\+\_\+attr, }
\item[{char $\ast$}]{new\+\_\+table\+\_\+name, }
\item[{char $\ast$}]{new\+\_\+attr}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_a7c72abd64691fabe0326bfb0a4a7e187}{}\label{table_8h_a7c72abd64691fabe0326bfb0a4a7e187}


Function for renaming table and/or attribute in table (moved from rename.\+c) 

\begin{DoxyAuthor}{Author}
Mislav Čakarić edited by Ljubo Barać 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em old\+\_\+table\+\_\+name} & old name of the table \\
\hline
{\em new\+\_\+table\+\_\+name} & new name of the table \\
\hline
{\em old\+\_\+attr} & name of the attribute to rename \\
\hline
{\em new\+\_\+attr} & new name for the attribute to rename \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+E\+R\+R\+OR or E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+table\+\_\+empty@{A\+K\+\_\+table\+\_\+empty}}
\index{A\+K\+\_\+table\+\_\+empty@{A\+K\+\_\+table\+\_\+empty}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+table\+\_\+empty(char $\ast$tbl\+Name)}{AK_table_empty(char *tblName)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+table\+\_\+empty (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{tbl\+Name}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_acddbb862c04235d408075c351cd68a59}{}\label{table_8h_acddbb862c04235d408075c351cd68a59}


Function that check whether table is empty. 

\begin{DoxyAuthor}{Author}
Matija Šestak. 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em $\ast$tbl\+Name} & table name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true/false 
\end{DoxyReturn}
\index{table.\+h@{table.\+h}!A\+K\+\_\+table\+\_\+test@{A\+K\+\_\+table\+\_\+test}}
\index{A\+K\+\_\+table\+\_\+test@{A\+K\+\_\+table\+\_\+test}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+table\+\_\+test()}{AK_table_test()}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+table\+\_\+test (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_a90a0fc1f502e0dcecffa983af7ec2019}{}\label{table_8h_a90a0fc1f502e0dcecffa983af7ec2019}


Function for testing table abstraction. 

\begin{DoxyAuthor}{Author}
Unknown 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
No return value
\end{DoxyReturn}
by Ana-\/\+Marija Balen -\/ added get\+Row function to the test \index{table.\+h@{table.\+h}!A\+K\+\_\+tuple\+\_\+to\+\_\+string@{A\+K\+\_\+tuple\+\_\+to\+\_\+string}}
\index{A\+K\+\_\+tuple\+\_\+to\+\_\+string@{A\+K\+\_\+tuple\+\_\+to\+\_\+string}!table.\+h@{table.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+tuple\+\_\+to\+\_\+string(struct list\+\_\+node $\ast$tuple)}{AK_tuple_to_string(struct list_node *tuple)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ A\+K\+\_\+tuple\+\_\+to\+\_\+string (
\begin{DoxyParamCaption}
\item[{struct list\+\_\+node $\ast$}]{tuple}
\end{DoxyParamCaption}
)}\hypertarget{table_8h_a1364e5d1a774d82e11537323714149b7}{}\label{table_8h_a1364e5d1a774d82e11537323714149b7}


Function that converts tuple value to string. 

\begin{DoxyAuthor}{Author}
Matija Šestak. 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em $\ast$tuple} & tuple in the list \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
tuple value as a string 
\end{DoxyReturn}
