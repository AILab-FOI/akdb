\hypertarget{rel__eq__comut_8c}{\section{opti/rel\+\_\+eq\+\_\+comut.c File Reference}
\label{rel__eq__comut_8c}\index{opti/rel\+\_\+eq\+\_\+comut.\+c@{opti/rel\+\_\+eq\+\_\+comut.\+c}}
}
{\ttfamily \#include \char`\"{}rel\+\_\+eq\+\_\+comut.\+h\char`\"{}}\\*
Include dependency graph for rel\+\_\+eq\+\_\+comut.\+c\+:
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{rel__eq__comut_8c_ae764cf4e0e534c7ecddcf8bbf556abab}{A\+K\+\_\+print\+\_\+rel\+\_\+eq\+\_\+comut} (struct list\+\_\+node $\ast$list\+\_\+rel\+\_\+eq)
\begin{DoxyCompactList}\small\item\em Function for printing optimized relation equivalence expression list regarding commutativity. \end{DoxyCompactList}\item 
struct list\+\_\+node $\ast$ \hyperlink{rel__eq__comut_8c_adc660067d03f9c0b4d36f21ffc6b2e21}{A\+K\+\_\+rel\+\_\+eq\+\_\+comut} (struct list\+\_\+node $\ast$list\+\_\+rel\+\_\+eq)
\begin{DoxyCompactList}\small\item\em Main function for generating R\+A expresion according to commutativity equivalence rules. \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{rel__eq__comut_8c_ac99e121b9f1ceb81bdcd116a6d2bb4bc}{A\+K\+\_\+rel\+\_\+eq\+\_\+commute\+\_\+with\+\_\+theta\+\_\+join} (char $\ast$cond, char $\ast$tbl\+Name)
\begin{DoxyCompactList}\small\item\em Check if selection can commute with theta-\/join or product. \end{DoxyCompactList}\item 
void \hyperlink{rel__eq__comut_8c_a8aab27cdd73ea98784ab6bafaaddafa2}{A\+K\+\_\+rel\+\_\+eq\+\_\+comut\+\_\+test} ()
\begin{DoxyCompactList}\small\item\em relational equivalences regarding commutativity \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Provides functions for relational equivalences regarding commutativity 

\subsection{Function Documentation}
\hypertarget{rel__eq__comut_8c_ae764cf4e0e534c7ecddcf8bbf556abab}{\index{rel\+\_\+eq\+\_\+comut.\+c@{rel\+\_\+eq\+\_\+comut.\+c}!A\+K\+\_\+print\+\_\+rel\+\_\+eq\+\_\+comut@{A\+K\+\_\+print\+\_\+rel\+\_\+eq\+\_\+comut}}
\index{A\+K\+\_\+print\+\_\+rel\+\_\+eq\+\_\+comut@{A\+K\+\_\+print\+\_\+rel\+\_\+eq\+\_\+comut}!rel\+\_\+eq\+\_\+comut.\+c@{rel\+\_\+eq\+\_\+comut.\+c}}
\subsubsection[{A\+K\+\_\+print\+\_\+rel\+\_\+eq\+\_\+comut}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+print\+\_\+rel\+\_\+eq\+\_\+comut (
\begin{DoxyParamCaption}
\item[{struct list\+\_\+node $\ast$}]{list\+\_\+rel\+\_\+eq}
\end{DoxyParamCaption}
)}}\label{rel__eq__comut_8c_ae764cf4e0e534c7ecddcf8bbf556abab}


Function for printing optimized relation equivalence expression list regarding commutativity. 

\begin{DoxyAuthor}{Author}
Davor Tomala 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em $\ast$list\+\_\+rel\+\_\+eq} & R\+A expresion as the struct list\+\_\+node \\
\hline
\end{DoxyParams}
\hypertarget{rel__eq__comut_8c_ac99e121b9f1ceb81bdcd116a6d2bb4bc}{\index{rel\+\_\+eq\+\_\+comut.\+c@{rel\+\_\+eq\+\_\+comut.\+c}!A\+K\+\_\+rel\+\_\+eq\+\_\+commute\+\_\+with\+\_\+theta\+\_\+join@{A\+K\+\_\+rel\+\_\+eq\+\_\+commute\+\_\+with\+\_\+theta\+\_\+join}}
\index{A\+K\+\_\+rel\+\_\+eq\+\_\+commute\+\_\+with\+\_\+theta\+\_\+join@{A\+K\+\_\+rel\+\_\+eq\+\_\+commute\+\_\+with\+\_\+theta\+\_\+join}!rel\+\_\+eq\+\_\+comut.\+c@{rel\+\_\+eq\+\_\+comut.\+c}}
\subsubsection[{A\+K\+\_\+rel\+\_\+eq\+\_\+commute\+\_\+with\+\_\+theta\+\_\+join}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ A\+K\+\_\+rel\+\_\+eq\+\_\+commute\+\_\+with\+\_\+theta\+\_\+join (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{cond, }
\item[{char $\ast$}]{tbl\+Name}
\end{DoxyParamCaption}
)}}\label{rel__eq__comut_8c_ac99e121b9f1ceb81bdcd116a6d2bb4bc}


Check if selection can commute with theta-\/join or product. 

\begin{DoxyAuthor}{Author}
Dino Laktašić. 
\begin{DoxyEnumerate}
\item For each token (delimited by \char`\"{} \char`\"{}) in selection condition first check if token represents attribute/s and is subset in the given table 
\item If token is a subset set variable id to 1 
\item else set id to 0, else make no changes to variable id 
\item if token differs from \char`\"{}\+A\+N\+D\char`\"{} and \char`\"{}\+O\+R\char`\"{} and id equals to 1 append current token to result condition 
\item else if token equals to \char`\"{}\+A\+N\+D\char`\"{} or \char`\"{}\+O\+R\char`\"{} and id equals to 1 and there are two added tokens add \char`\"{}\+A\+N\+D\char`\"{} or \char`\"{}\+O\+R\char`\"{} to condition string 
\item When exits from loop, return pointer to char array that contains new condition for a given table 
\end{DoxyEnumerate}
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em $\ast$cond} & condition array that contains condition data \\
\hline
{\em $\ast$tbl\+Name} & name of the table \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to char array that contains new condition for a given table 
\end{DoxyReturn}
\hypertarget{rel__eq__comut_8c_adc660067d03f9c0b4d36f21ffc6b2e21}{\index{rel\+\_\+eq\+\_\+comut.\+c@{rel\+\_\+eq\+\_\+comut.\+c}!A\+K\+\_\+rel\+\_\+eq\+\_\+comut@{A\+K\+\_\+rel\+\_\+eq\+\_\+comut}}
\index{A\+K\+\_\+rel\+\_\+eq\+\_\+comut@{A\+K\+\_\+rel\+\_\+eq\+\_\+comut}!rel\+\_\+eq\+\_\+comut.\+c@{rel\+\_\+eq\+\_\+comut.\+c}}
\subsubsection[{A\+K\+\_\+rel\+\_\+eq\+\_\+comut}]{\setlength{\rightskip}{0pt plus 5cm}struct list\+\_\+node$\ast$ A\+K\+\_\+rel\+\_\+eq\+\_\+comut (
\begin{DoxyParamCaption}
\item[{struct list\+\_\+node $\ast$}]{list\+\_\+rel\+\_\+eq}
\end{DoxyParamCaption}
)}}\label{rel__eq__comut_8c_adc660067d03f9c0b4d36f21ffc6b2e21}


Main function for generating R\+A expresion according to commutativity equivalence rules. 

\begin{DoxyAuthor}{Author}
Davor Tomala 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em $\ast$list\+\_\+rel\+\_\+eq} & R\+A expresion as the struct list\+\_\+node \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
optimised R\+A expresion as the struct list\+\_\+node 
\end{DoxyReturn}
\hypertarget{rel__eq__comut_8c_a8aab27cdd73ea98784ab6bafaaddafa2}{\index{rel\+\_\+eq\+\_\+comut.\+c@{rel\+\_\+eq\+\_\+comut.\+c}!A\+K\+\_\+rel\+\_\+eq\+\_\+comut\+\_\+test@{A\+K\+\_\+rel\+\_\+eq\+\_\+comut\+\_\+test}}
\index{A\+K\+\_\+rel\+\_\+eq\+\_\+comut\+\_\+test@{A\+K\+\_\+rel\+\_\+eq\+\_\+comut\+\_\+test}!rel\+\_\+eq\+\_\+comut.\+c@{rel\+\_\+eq\+\_\+comut.\+c}}
\subsubsection[{A\+K\+\_\+rel\+\_\+eq\+\_\+comut\+\_\+test}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+rel\+\_\+eq\+\_\+comut\+\_\+test (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{rel__eq__comut_8c_a8aab27cdd73ea98784ab6bafaaddafa2}


relational equivalences regarding commutativity 

\begin{DoxyAuthor}{Author}
Dino Laktašić (A\+K\+\_\+rel\+\_\+eq\+\_\+commute\+\_\+with\+\_\+theta\+\_\+join), Davor Tomala (A\+K\+\_\+rel\+\_\+eq\+\_\+comut) 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
No return vlaue 
\end{DoxyReturn}
