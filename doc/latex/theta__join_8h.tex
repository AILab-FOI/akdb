\hypertarget{theta__join_8h}{\section{rel/theta\+\_\+join.h File Reference}
\label{theta__join_8h}\index{rel/theta\+\_\+join.\+h@{rel/theta\+\_\+join.\+h}}
}
{\ttfamily \#include \char`\"{}expression\+\_\+check.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}../file/fileio.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}../auxi/mempro.\+h\char`\"{}}\\*
Include dependency graph for theta\+\_\+join.\+h\+:
This graph shows which files directly or indirectly include this file\+:
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{theta__join_8h_ac229e6488e438dc8b81b21336f25b09c}{A\+K\+\_\+theta\+\_\+join} (char $\ast$src\+Table1, char $\ast$src\+Table2, char $\ast$dst\+Table, struct list\+\_\+node $\ast$constraints)
\begin{DoxyCompactList}\small\item\em Function for creating a theta join betwen two tables on specified conditions. Names of the attibutes in the constraints parameter must be prefixed with the table name followed by a dot if and only if they exist in both tables. This is left for the preprocessing. Also, for now the constraints must come from the two source tables and not from a third. \end{DoxyCompactList}\item 
int \hyperlink{theta__join_8h_a52fbdb3f076762aff6f2533b2c68a95b}{A\+K\+\_\+create\+\_\+theta\+\_\+join\+\_\+header} (char $\ast$src\+Table1, char $\ast$src\+Table2, char $\ast$new\+\_\+table)
\begin{DoxyCompactList}\small\item\em Function for creating the header of the new table for theta join. \end{DoxyCompactList}\item 
void \hyperlink{theta__join_8h_a6cc06221d7a4b4d337236515ca4f11e4}{A\+K\+\_\+check\+\_\+constraints} (\hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$tbl1\+\_\+temp\+\_\+block, \hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$tbl2\+\_\+temp\+\_\+block, int tbl1\+\_\+num\+\_\+att, int tbl2\+\_\+num\+\_\+att, struct list\+\_\+node $\ast$constraints, char $\ast$new\+\_\+table)
\begin{DoxyCompactList}\small\item\em Function iterates through blocks of the two tables and copies the rows which pass the constraint check into the new table. \end{DoxyCompactList}\item 
void \hyperlink{theta__join_8h_a79338e9866f3daa448b9154fcba844af}{A\+K\+\_\+op\+\_\+theta\+\_\+join\+\_\+test} ()
\begin{DoxyCompactList}\small\item\em Function for testing the theta join. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Header file that provides data structures for theta-\/join 

\subsection{Function Documentation}
\hypertarget{theta__join_8h_a6cc06221d7a4b4d337236515ca4f11e4}{\index{theta\+\_\+join.\+h@{theta\+\_\+join.\+h}!A\+K\+\_\+check\+\_\+constraints@{A\+K\+\_\+check\+\_\+constraints}}
\index{A\+K\+\_\+check\+\_\+constraints@{A\+K\+\_\+check\+\_\+constraints}!theta\+\_\+join.\+h@{theta\+\_\+join.\+h}}
\subsubsection[{A\+K\+\_\+check\+\_\+constraints}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+check\+\_\+constraints (
\begin{DoxyParamCaption}
\item[{{\bf A\+K\+\_\+block} $\ast$}]{tbl1\+\_\+temp\+\_\+block, }
\item[{{\bf A\+K\+\_\+block} $\ast$}]{tbl2\+\_\+temp\+\_\+block, }
\item[{int}]{tbl1\+\_\+num\+\_\+att, }
\item[{int}]{tbl2\+\_\+num\+\_\+att, }
\item[{struct list\+\_\+node $\ast$}]{constraints, }
\item[{char $\ast$}]{new\+\_\+table}
\end{DoxyParamCaption}
)}}\label{theta__join_8h_a6cc06221d7a4b4d337236515ca4f11e4}


Function iterates through blocks of the two tables and copies the rows which pass the constraint check into the new table. 

\begin{DoxyAuthor}{Author}
Tomislav Mikul훾ek 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em tbl1\+\_\+temp\+\_\+block} & block of the first table \\
\hline
{\em tbl2\+\_\+temp\+\_\+block} & block of the second join table \\
\hline
{\em tbl1\+\_\+num\+\_\+att} & number of attributes in the first table \\
\hline
{\em tbl2\+\_\+num\+\_\+att} & number of attributes in the second table \\
\hline
{\em constraints} & list of attributes, (in)equality and logical operators which are the conditions for the join in postfix notation \\
\hline
{\em new\+\_\+table} & name of the theta\+\_\+join table \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
No return value 
\end{DoxyReturn}
\hypertarget{theta__join_8h_a52fbdb3f076762aff6f2533b2c68a95b}{\index{theta\+\_\+join.\+h@{theta\+\_\+join.\+h}!A\+K\+\_\+create\+\_\+theta\+\_\+join\+\_\+header@{A\+K\+\_\+create\+\_\+theta\+\_\+join\+\_\+header}}
\index{A\+K\+\_\+create\+\_\+theta\+\_\+join\+\_\+header@{A\+K\+\_\+create\+\_\+theta\+\_\+join\+\_\+header}!theta\+\_\+join.\+h@{theta\+\_\+join.\+h}}
\subsubsection[{A\+K\+\_\+create\+\_\+theta\+\_\+join\+\_\+header}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+create\+\_\+theta\+\_\+join\+\_\+header (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{src\+Table1, }
\item[{char $\ast$}]{src\+Table2, }
\item[{char $\ast$}]{new\+\_\+table}
\end{DoxyParamCaption}
)}}\label{theta__join_8h_a52fbdb3f076762aff6f2533b2c68a95b}


Function for creating the header of the new table for theta join. 

\begin{DoxyAuthor}{Author}
Tomislav Mikul훾ek 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em src\+Table1} & name of the first table \\
\hline
{\em src\+Table2} & name of the second table \\
\hline
{\em new\+\_\+table} & name of the destination table \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S if the header was successfully created and E\+X\+I\+T\+\_\+\+E\+R\+R\+O\+R if the renamed headers are too long 
\end{DoxyReturn}
\hypertarget{theta__join_8h_a79338e9866f3daa448b9154fcba844af}{\index{theta\+\_\+join.\+h@{theta\+\_\+join.\+h}!A\+K\+\_\+op\+\_\+theta\+\_\+join\+\_\+test@{A\+K\+\_\+op\+\_\+theta\+\_\+join\+\_\+test}}
\index{A\+K\+\_\+op\+\_\+theta\+\_\+join\+\_\+test@{A\+K\+\_\+op\+\_\+theta\+\_\+join\+\_\+test}!theta\+\_\+join.\+h@{theta\+\_\+join.\+h}}
\subsubsection[{A\+K\+\_\+op\+\_\+theta\+\_\+join\+\_\+test}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+op\+\_\+theta\+\_\+join\+\_\+test (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{theta__join_8h_a79338e9866f3daa448b9154fcba844af}


Function for testing the theta join. 

\begin{DoxyAuthor}{Author}
Tomislav Mikul훾ek 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
No return value 
\end{DoxyReturn}
\hypertarget{theta__join_8h_ac229e6488e438dc8b81b21336f25b09c}{\index{theta\+\_\+join.\+h@{theta\+\_\+join.\+h}!A\+K\+\_\+theta\+\_\+join@{A\+K\+\_\+theta\+\_\+join}}
\index{A\+K\+\_\+theta\+\_\+join@{A\+K\+\_\+theta\+\_\+join}!theta\+\_\+join.\+h@{theta\+\_\+join.\+h}}
\subsubsection[{A\+K\+\_\+theta\+\_\+join}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+theta\+\_\+join (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{src\+Table1, }
\item[{char $\ast$}]{src\+Table2, }
\item[{char $\ast$}]{dst\+Table, }
\item[{struct list\+\_\+node $\ast$}]{constraints}
\end{DoxyParamCaption}
)}}\label{theta__join_8h_ac229e6488e438dc8b81b21336f25b09c}


Function for creating a theta join betwen two tables on specified conditions. Names of the attibutes in the constraints parameter must be prefixed with the table name followed by a dot if and only if they exist in both tables. This is left for the preprocessing. Also, for now the constraints must come from the two source tables and not from a third. 

\begin{DoxyAuthor}{Author}
Tomislav Mikul훾ek,updated by Nikola Miljancic 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em src\+Table1} & name of the first table to join \\
\hline
{\em src\+Table2} & name of the second table to join \\
\hline
{\em constraints} & list of attributes, (in)equality and logical operators which are the conditions for the join in postfix notation \\
\hline
{\em dst\+Table} & name of the theta join table \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
if successful returns E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S and E\+X\+I\+T\+\_\+\+E\+R\+R\+O\+R otherwise 
\end{DoxyReturn}
