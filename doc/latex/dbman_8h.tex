\hypertarget{dbman_8h}{}\section{dm/dbman.h File Reference}
\label{dbman_8h}\index{dm/dbman.\+h@{dm/dbman.\+h}}
{\ttfamily \#include \char`\"{}../auxi/auxiliary.\+h\char`\"{}}\\*
{\ttfamily \#include $<$errno.\+h$>$}\\*
{\ttfamily \#include $<$pthread.\+h$>$}\\*
{\ttfamily \#include \char`\"{}sys/time.\+h\char`\"{}}\\*
{\ttfamily \#include $<$sys/types.\+h$>$}\\*
{\ttfamily \#include $<$sys/stat.\+h$>$}\\*
{\ttfamily \#include $<$fcntl.\+h$>$}\\*
{\ttfamily \#include \char`\"{}../auxi/mempro.\+h\char`\"{}}\\*
{\ttfamily \#include $<$limits.\+h$>$}\\*
Include dependency graph for dbman.\+h\+:
% FIG 0
This graph shows which files directly or indirectly include this file\+:
% FIG 1
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structAK__header}{A\+K\+\_\+header}
\begin{DoxyCompactList}\small\item\em Structure that represents header structure of blocks (describes an attribute inside an object). It contains type, attribute name, integrity, constraint name and constraint code. \end{DoxyCompactList}\item 
struct \hyperlink{structAK__tuple__dict}{A\+K\+\_\+tuple\+\_\+dict}
\begin{DoxyCompactList}\small\item\em Structure that defines a mapping in a header of an object to the actual entries (data). It contains type, address and size. \end{DoxyCompactList}\item 
struct \hyperlink{structAK__block}{A\+K\+\_\+block}
\begin{DoxyCompactList}\small\item\em Structure that defines a block of data inside a DB file. It contains address, type, chained\+\_\+with, A\+K\+\_\+free space, last\+\_\+tuple\+\_\+dict\+\_\+id, header and tuple\+\_\+dict and data. \end{DoxyCompactList}\item 
struct \hyperlink{structtable__addresses}{table\+\_\+addresses}
\begin{DoxyCompactList}\small\item\em Structure that defines start and end address of extent. \end{DoxyCompactList}\item 
struct \hyperlink{structAK__blocktable}{A\+K\+\_\+blocktable}
\item 
struct \hyperlink{structAK__block__activity}{A\+K\+\_\+block\+\_\+activity}
\begin{DoxyCompactList}\small\item\em Structure which holds information about each block, whether it is locked for reading or writing. It is important to note such information, to enable quick and thread-\/safe reading from or writing to disk. Structure contains of\+: locked\+\_\+for\+\_\+reading -\/ thread which locks particular block for reading will set this value locked\+\_\+for\+\_\+writing -\/ thread which locks particular block for writing will set this value block\+\_\+lock -\/ each reading and writing operation will be done atomically and uninteruptable, using this mutex block lock reading\+\_\+done -\/ represents signal, which sends thread that just finished reading block. This signal will indicate that writing thread can start writing to block writing\+\_\+done -\/ represents signal, which sends thread that just finished writing to block. This signal will indicate that other threads can start reading from this block or even writing to it thread\+\_\+holding\+\_\+lock -\/ the only thread which can unlock locked \char`\"{}block\+\_\+lock\char`\"{} is the one that locked it. This variable makes sure that O\+N\+LY the thread, which actually holds the lock, releases it. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define {\bfseries B\+I\+T\+M\+A\+SK}(b)~(1 $<$$<$ ((b) \% C\+H\+A\+R\+\_\+\+B\+IT))\hypertarget{dbman_8h_a56ea45a33eb7554bf2be6e058650e7d3}{}\label{dbman_8h_a56ea45a33eb7554bf2be6e058650e7d3}

\item 
\#define {\bfseries B\+I\+T\+S\+L\+OT}(b)~((int)((b) / C\+H\+A\+R\+\_\+\+B\+IT))\hypertarget{dbman_8h_affca3920d37bd52be836c52c29ba03fc}{}\label{dbman_8h_affca3920d37bd52be836c52c29ba03fc}

\item 
\#define {\bfseries B\+I\+T\+S\+ET}(a,  b)~((a)\mbox{[}B\+I\+T\+S\+L\+OT(b)\mbox{]} $\vert$= B\+I\+T\+M\+A\+SK(b))\hypertarget{dbman_8h_af6799ea240e508a976ba685194413700}{}\label{dbman_8h_af6799ea240e508a976ba685194413700}

\item 
\#define {\bfseries B\+I\+T\+C\+L\+E\+AR}(a,  b)~((a)\mbox{[}B\+I\+T\+S\+L\+OT(b)\mbox{]} \&= $\sim$B\+I\+T\+M\+A\+SK(b))\hypertarget{dbman_8h_ae8895d7d3fe1910f9f72e649a1267d91}{}\label{dbman_8h_ae8895d7d3fe1910f9f72e649a1267d91}

\item 
\#define {\bfseries B\+I\+T\+T\+E\+ST}(a,  b)~((a)\mbox{[}B\+I\+T\+S\+L\+OT(b)\mbox{]} \& B\+I\+T\+M\+A\+SK(b))\hypertarget{dbman_8h_ac3d6a2f68f2fbb834c2b943f67f3dc56}{}\label{dbman_8h_ac3d6a2f68f2fbb834c2b943f67f3dc56}

\item 
\#define {\bfseries B\+I\+T\+N\+S\+L\+O\+TS}(nb)~((int)(nb + C\+H\+A\+R\+\_\+\+B\+IT -\/ 1) / C\+H\+A\+R\+\_\+\+B\+IT)\hypertarget{dbman_8h_a1802cc85978a831e0d756dc05d697fba}{}\label{dbman_8h_a1802cc85978a831e0d756dc05d697fba}

\item 
\#define {\bfseries S\+E\+G\+M\+E\+N\+T\+L\+E\+N\+G\+TH}()~(B\+I\+T\+N\+S\+L\+O\+TS(D\+B\+\_\+\+F\+I\+L\+E\+\_\+\+B\+L\+O\+C\+K\+S\+\_\+\+N\+UM) + 2$\ast$sizeof(int))\hypertarget{dbman_8h_aee56d7cf0d896bae86db3f5b7eb7dcbe}{}\label{dbman_8h_aee56d7cf0d896bae86db3f5b7eb7dcbe}

\item 
\#define {\bfseries D\+B\+\_\+\+F\+I\+L\+E\+\_\+\+S\+I\+Z\+E\+\_\+\+EX}~40\hypertarget{dbman_8h_aee151a4c2c7c6a2e40977838affd5900}{}\label{dbman_8h_aee151a4c2c7c6a2e40977838affd5900}

\item 
\#define {\bfseries D\+B\+\_\+\+F\+I\+L\+E\+\_\+\+B\+L\+O\+C\+K\+S\+\_\+\+N\+U\+M\+\_\+\+EX}~(int)(1024 $\ast$ 1024 $\ast$ D\+B\+\_\+\+F\+I\+L\+E\+\_\+\+S\+I\+Z\+E\+\_\+\+EX / sizeof(\hyperlink{structAK__block}{A\+K\+\_\+block}))\hypertarget{dbman_8h_acb9963ec4e3a4bce5dcde3f8f8cd319f}{}\label{dbman_8h_acb9963ec4e3a4bce5dcde3f8f8cd319f}

\item 
\#define \hyperlink{dbman_8h_a865f46f25d301f8f7df73203708c3aca}{A\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE}~sizeof(\hyperlink{structAK__blocktable}{A\+K\+\_\+blocktable})
\begin{DoxyCompactList}\small\item\em Holds size of allocation table. \end{DoxyCompactList}\item 
\#define \hyperlink{dbman_8h_ae3557aeeb51dd7ed09d2cdd03cf25816}{C\+H\+A\+R\+\_\+\+I\+N\+\_\+\+L\+I\+NE}~80
\begin{DoxyCompactList}\small\item\em How many characters could line contain. \end{DoxyCompactList}\item 
\#define \hyperlink{dbman_8h_a962b5fc404942e51ae0049dde505590e}{M\+A\+X\+\_\+\+B\+L\+O\+C\+K\+\_\+\+I\+N\+I\+T\+\_\+\+N\+UM}~M\+A\+X\+\_\+\+C\+A\+C\+H\+E\+\_\+\+M\+E\+M\+O\+RY
\begin{DoxyCompactList}\small\item\em How many blocks would be initially allocated. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{dbman_8h_af6d80074e26af6570de6d650c1d90851}{A\+K\+\_\+allocation\+\_\+set\+\_\+mode} \{ \\*
{\bfseries allocation\+S\+E\+Q\+U\+E\+N\+CE} = 10001, 
{\bfseries allocation\+U\+P\+P\+ER}, 
{\bfseries allocation\+L\+O\+W\+ER}, 
{\bfseries allocation\+A\+R\+O\+U\+ND}, 
\\*
{\bfseries allocation\+N\+O\+M\+O\+DE}
 \}\begin{DoxyCompactList}\small\item\em Different modes to obtain allocation indexes\+: S\+E\+Q\+U\+E\+N\+CE -\/ first found set of sequence indexes U\+P\+P\+ER -\/ set tries to place itself to upper part od allocation table L\+O\+W\+ER -\/ set tries to place itself to lower part od allocation table A\+R\+O\+U\+ND -\/ set tries to place itself around targeted index. \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{dbman_8h_a3fcca519b1dbe309c683d64b0e955dca}{A\+K\+\_\+print\+\_\+block} (\hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$block, int num, char $\ast$gg, F\+I\+LE $\ast$fpp)
\begin{DoxyCompactList}\small\item\em Function that dumps block. \end{DoxyCompactList}\item 
void {\bfseries A\+K\+\_\+allocationbit\+\_\+test} ()\hypertarget{dbman_8h_a195049d1c2185a540f18cf1711e2f448}{}\label{dbman_8h_a195049d1c2185a540f18cf1711e2f448}

\item 
void {\bfseries A\+K\+\_\+allocationtable\+\_\+test} ()\hypertarget{dbman_8h_a35e134c23957bd5971723676e5fb4a2d}{}\label{dbman_8h_a35e134c23957bd5971723676e5fb4a2d}

\item 
int $\ast$ \hyperlink{dbman_8h_a9411aae916046fdd8e53ed1760a58b6d}{A\+K\+\_\+increase\+\_\+extent} (int start\+\_\+address, int add\+\_\+size, \hyperlink{dbman_8h_af6d80074e26af6570de6d650c1d90851}{A\+K\+\_\+allocation\+\_\+set\+\_\+mode} $\ast$mode, int border, int target, \hyperlink{structAK__header}{A\+K\+\_\+header} $\ast$header, int gl)
\begin{DoxyCompactList}\small\item\em Function alocates new blocks for increasing extent size. \end{DoxyCompactList}\item 
int $\ast$ \hyperlink{dbman_8h_a9525b11c47b5825abb4956add526623c}{A\+K\+\_\+get\+\_\+extent} (int start\+\_\+address, int desired\+\_\+size, \hyperlink{dbman_8h_af6d80074e26af6570de6d650c1d90851}{A\+K\+\_\+allocation\+\_\+set\+\_\+mode} $\ast$mode, int border, int target, \hyperlink{structAK__header}{A\+K\+\_\+header} $\ast$header, int gl)
\begin{DoxyCompactList}\small\item\em Function alocates new extent of blocks. Number of blocks is not ordered as well as a way of search for them. \end{DoxyCompactList}\item 
int $\ast$ \hyperlink{dbman_8h_a377b7d3e346a2cbe608d468f4274cda8}{A\+K\+\_\+get\+\_\+allocation\+\_\+set} (int $\ast$bitsetbs, int from\+Where, int gaplength, int num, \hyperlink{dbman_8h_af6d80074e26af6570de6d650c1d90851}{A\+K\+\_\+allocation\+\_\+set\+\_\+mode} mode, int target)
\begin{DoxyCompactList}\small\item\em Function prepare demanded sets from allocation table. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_ad4d4a6ea2344a3003ea50930cc0e77b8}{A\+K\+\_\+copy\+\_\+header} (\hyperlink{structAK__header}{A\+K\+\_\+header} $\ast$header, int $\ast$blocknum, int num)
\begin{DoxyCompactList}\small\item\em Function copy header to blocks. Completely thread-\/safe. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_ac48b8ab357cefa4ffcc54c348571c1fe}{A\+K\+\_\+allocate\+\_\+blocks} (F\+I\+LE $\ast$\hyperlink{dbman_8h_a89a7f6028a19c3dc081cc5f16eb53891}{db}, \hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$block, int From\+Where, int How\+Many)
\begin{DoxyCompactList}\small\item\em Function that allocates new blocks by placing them to appropriate place and then update last initialized index. \end{DoxyCompactList}\item 
\hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$ \hyperlink{dbman_8h_a402f984ce7298e193a2a9c5dc5d6b901}{A\+K\+\_\+init\+\_\+block} ()
\begin{DoxyCompactList}\small\item\em Function that initializes new block. \end{DoxyCompactList}\item 
void \hyperlink{dbman_8h_acf09d102942a1534d53d89489591af1b}{A\+K\+\_\+allocationtable\+\_\+dump} (int zz)
\begin{DoxyCompactList}\small\item\em Function dumpes allocation table. \end{DoxyCompactList}\item 
void \hyperlink{dbman_8h_a3956a7198427c0911c2775d382842b98}{A\+K\+\_\+blocktable\+\_\+dump} (int zz)
\begin{DoxyCompactList}\small\item\em Function dumpes allocation table. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_aef4ddae5253862ad465b91b1e940a71f}{A\+K\+\_\+blocktable\+\_\+flush} ()
\begin{DoxyCompactList}\small\item\em Function flushes bitmask table to disk. \end{DoxyCompactList}\item 
void \hyperlink{dbman_8h_a41ad69e55d09ab4aa2bec6dd34805367}{A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test} ()
\begin{DoxyCompactList}\small\item\em This function tests thread safe reading and writing to blocks. There is N writing and N reading threads, which are going through iterations. Each reading thread should read the data (character) that was set by last writing thread. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{dbman_8h_a5499694bd97b104560d14ef70abe2c73}{A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing} (void $\ast$address)
\begin{DoxyCompactList}\small\item\em This function is only for testing. It has to be there, because pthread\+\_\+create only accepts void$\ast$ function\+\_\+name (void $\ast$) function format. So A\+K\+\_\+read\+\_\+block is no-\/go for pthread\+\_\+create. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{dbman_8h_a0558e034eeed865a1c855de5cfad20ef}{A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing} (void $\ast$block)
\begin{DoxyCompactList}\small\item\em This function is only for testing. It has to be there, because pthread\+\_\+create only accepts void$\ast$ function\+\_\+name (void $\ast$) function format. So A\+K\+\_\+write\+\_\+block is no-\/go for pthread\+\_\+create. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_adcfd5252c0eed066034b558df30cc790}{A\+K\+\_\+blocktable\+\_\+get} ()
\begin{DoxyCompactList}\small\item\em Function gets allocation table from disk. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_adbc6978517271fbd48a004cb039ac6c1}{fsize} (F\+I\+LE $\ast$fp)
\begin{DoxyCompactList}\small\item\em Helper function to determine file size. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_aee0b4429858370953a410c6fb5b9ec92}{A\+K\+\_\+init\+\_\+allocation\+\_\+table} ()
\begin{DoxyCompactList}\small\item\em Function that initializes allocation table, write it to disk and cache in memory. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_a7cacca7e9aebff2aee36f85632e5c35e}{A\+K\+\_\+init\+\_\+db\+\_\+file} (int size)
\begin{DoxyCompactList}\small\item\em Function that initializes a new database file named D\+B\+\_\+\+F\+I\+LE. It opens database file. New block is allocated. In this block type of header is set to F\+R\+E\+E\+\_\+\+I\+NT, attribute names are set to F\+R\+E\+E\+\_\+\+C\+H\+AR, integrities are set to F\+R\+E\+E\+\_\+\+I\+NT, constraint names are set to F\+R\+E\+E\+\_\+\+C\+H\+AR, constraint names and codes are set to F\+R\+E\+E\+\_\+\+C\+H\+AR. Type, address and size of tuples are set to F\+R\+E\+E\+\_\+\+I\+NT. Data in block is set to F\+R\+E\+E\+\_\+\+C\+H\+AR. Type of block is B\+L\+O\+C\+K\+\_\+\+T\+Y\+P\+E\+\_\+\+F\+R\+EE, it is not chained and id of last tuple is 0. \end{DoxyCompactList}\item 
\hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$ \hyperlink{dbman_8h_a2c880db7cf4f8332ae7e93c6b71cc911}{A\+K\+\_\+read\+\_\+block} (int address)
\begin{DoxyCompactList}\small\item\em Function that reads a block at a given address (block number less than db\+\_\+file\+\_\+size). New block is allocated. Database file is opened. Position is set to provided address block. At the end function reads file from that position. Completely thread-\/safe. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_a222ea31aa276d52e464137a3b144f78a}{A\+K\+\_\+write\+\_\+block} (\hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$block)
\begin{DoxyCompactList}\small\item\em Function writes a block to DB file. Database file is opened. Position is set to provided address block. Block is written to provided address. Completely thread-\/safe. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_a1ff7d6ea92a45cda91ff2063043900a1}{A\+K\+\_\+new\+\_\+extent} (int start\+\_\+address, int old\+\_\+size, int extent\+\_\+type, \hyperlink{structAK__header}{A\+K\+\_\+header} $\ast$header)
\begin{DoxyCompactList}\small\item\em Function alocates new extent of blocks. If argument \char`\"{}old\+\_\+size\char`\"{} is 0 than size of extent is I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE. Otherwise, resize factor is set according to type of extent. If writing of block is successful, number of blocks is incremented. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_a79e7998e69e2910528f7ef258469b2be}{A\+K\+\_\+new\+\_\+segment} (char $\ast$name, int type, \hyperlink{structAK__header}{A\+K\+\_\+header} $\ast$header)
\begin{DoxyCompactList}\small\item\em Function that allocates new segment of extents. In this phase of implementation, only extents containing I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE blocks can be allocated. If extent is successfully allocated, number of allocated extents is incremented and function goes to next block after allocated extent. Otherwise, function moves to I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE blocks. In that way function gets either first block of new extent or some block in that extent which will not be A\+K\+\_\+free. \end{DoxyCompactList}\item 
\hyperlink{structAK__header}{A\+K\+\_\+header} $\ast$ \hyperlink{dbman_8h_adbd8d4f27d7e825392badfcfc4baf968}{A\+K\+\_\+create\+\_\+header} (char $\ast$name, int type, int integrity, char $\ast$constr\+\_\+name, char $\ast$contr\+\_\+code)
\begin{DoxyCompactList}\small\item\em Function for creating header and initalize integrity, constraint name and constraint code with parameter values of function. \end{DoxyCompactList}\item 
void \hyperlink{dbman_8h_a0f011234546a9f1cc751a0d08036b131}{A\+K\+\_\+insert\+\_\+entry} (\hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$block\+\_\+address, int type, void $\ast$entry\+\_\+data, int i)
\begin{DoxyCompactList}\small\item\em Function for inserting entry in tuple\+\_\+dict and data of a block. Address, type and size of catalog\+\_\+tuple\+\_\+dict are set. Free space of block is also set. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_ac48430852cddc2cc7b79dd2775212b10}{A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog} (int relation, int attribute, int index, int view, int sequence, int function, int function\+\_\+arguments, int trigger, int trigger\+\_\+conditions, int \hyperlink{dbman_8h_a89a7f6028a19c3dc081cc5f16eb53891}{db}, int db\+\_\+obj, int user, int group, int user\+\_\+group, int user\+\_\+right, int group\+\_\+right, int constraint, int constraint\+Null, int constraint\+Check, int constraint\+Unique, int reference)
\begin{DoxyCompactList}\small\item\em Function initialises the sytem table catalog and writes the result in first (0) block in db\+\_\+file. Catalog block, catalog header name, catalog header address are allocated. Address, type, chained\+\_\+with and A\+K\+\_\+free\+\_\+space attributes are initialized. Names of various database elements are written in block. \end{DoxyCompactList}\item 
void \hyperlink{dbman_8h_a3157bc3da79c19192a915acc1235bad0}{A\+K\+\_\+memset\+\_\+int} (void $\ast$block, int value, size\+\_\+t num)
\begin{DoxyCompactList}\small\item\em Function that sets the first num ints of a block of memory to the specified value. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_af4c050534ddf6dcf1cba09987424ff76}{A\+K\+\_\+register\+\_\+system\+\_\+tables} (int relation, int attribute, int index, int view, int sequence, int function, int function\+\_\+arguments, int trigger, int trigger\+\_\+conditions, int \hyperlink{dbman_8h_a89a7f6028a19c3dc081cc5f16eb53891}{db}, int db\+\_\+obj, int user, int group, int user\+\_\+group, int user\+\_\+right, int group\+\_\+right, int constraint, int constraint\+Null, int constraint\+Check, int constraint\+Unique, int reference)
\begin{DoxyCompactList}\small\item\em Function that registers system tables. Block at the given address is read. Various data from function arguments are written in block about different database elements. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_af99cdc5c8456ad5ff87fb542d030c4d6}{A\+K\+\_\+init\+\_\+system\+\_\+catalog} ()
\begin{DoxyCompactList}\small\item\em Function initializes the system catalog. Headers for system tables are defined. Segments for those system tables are allocated. Above function \hyperlink{dbman_8c_af4c050534ddf6dcf1cba09987424ff76}{A\+K\+\_\+register\+\_\+system\+\_\+tables()} to register system tables. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_a5058a1dd8adfdd5663626492f1d1f257}{A\+K\+\_\+delete\+\_\+block} (int address)
\begin{DoxyCompactList}\small\item\em Function deletes a block by a given block address (resets the header and data). Types, integrities, constraint names, constraint codes are set to \char`\"{}\+A\+K\+\_\+free\char`\"{} values. In tuple dictionary type, address and size are set to F\+R\+E\+E\+\_\+\+I\+NT values. Data of block is set to F\+R\+E\+E\+\_\+\+C\+H\+AR. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_a1c0ef3161f926bef80f12aa4e0905acd}{A\+K\+\_\+delete\+\_\+extent} (int begin, int end)
\begin{DoxyCompactList}\small\item\em Function deletes an extent between begin and end blocks. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8h_a0a6e9ee9800548168a235c26fcceba71}{A\+K\+\_\+delete\+\_\+segment} (char $\ast$name, int type)
\item 
int \hyperlink{dbman_8h_a7e7d6a4c56ce0c15b59217a3607db06e}{A\+K\+\_\+init\+\_\+disk\+\_\+manager} ()
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
F\+I\+LE $\ast$ \hyperlink{dbman_8h_a89a7f6028a19c3dc081cc5f16eb53891}{db}
\begin{DoxyCompactList}\small\item\em Variable that defines the DB file file handle. \end{DoxyCompactList}\item 
unsigned int \hyperlink{dbman_8h_afec6731df4a8f57725504d170bbec2d0}{db\+\_\+file\+\_\+size}
\begin{DoxyCompactList}\small\item\em Variable that defines the size of the DB file (in blocks) \end{DoxyCompactList}\item 
\hyperlink{structAK__blocktable}{A\+K\+\_\+blocktable} $\ast$ \hyperlink{dbman_8h_ab48e0673901ef82fcfc43f98627111df}{A\+K\+\_\+allocationbit}
\begin{DoxyCompactList}\small\item\em Global variable that holds allocation bit-\/vector. \end{DoxyCompactList}\item 
\hyperlink{structAK__block__activity}{A\+K\+\_\+block\+\_\+activity} $\ast$ {\bfseries A\+K\+\_\+block\+\_\+activity\+\_\+info}\hypertarget{dbman_8h_a69384cd2c960753c32a327819dc2568c}{}\label{dbman_8h_a69384cd2c960753c32a327819dc2568c}

\item 
A\+K\+\_\+synchronization\+\_\+info $\ast$ {\bfseries dbman\+File\+Lock}\hypertarget{dbman_8h_ad738b48765954d9532260f3d4d191567}{}\label{dbman_8h_ad738b48765954d9532260f3d4d191567}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Header file that defines includes and datastructures for the disk manager of Kalashnikov DB 

\subsection{Macro Definition Documentation}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE@{A\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE}}
\index{A\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE@{A\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE}{AK_ALLOCATION_TABLE_SIZE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define A\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE~sizeof({\bf A\+K\+\_\+blocktable})}\hypertarget{dbman_8h_a865f46f25d301f8f7df73203708c3aca}{}\label{dbman_8h_a865f46f25d301f8f7df73203708c3aca}


Holds size of allocation table. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\index{dbman.\+h@{dbman.\+h}!C\+H\+A\+R\+\_\+\+I\+N\+\_\+\+L\+I\+NE@{C\+H\+A\+R\+\_\+\+I\+N\+\_\+\+L\+I\+NE}}
\index{C\+H\+A\+R\+\_\+\+I\+N\+\_\+\+L\+I\+NE@{C\+H\+A\+R\+\_\+\+I\+N\+\_\+\+L\+I\+NE}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{C\+H\+A\+R\+\_\+\+I\+N\+\_\+\+L\+I\+NE}{CHAR_IN_LINE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define C\+H\+A\+R\+\_\+\+I\+N\+\_\+\+L\+I\+NE~80}\hypertarget{dbman_8h_ae3557aeeb51dd7ed09d2cdd03cf25816}{}\label{dbman_8h_ae3557aeeb51dd7ed09d2cdd03cf25816}


How many characters could line contain. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\index{dbman.\+h@{dbman.\+h}!M\+A\+X\+\_\+\+B\+L\+O\+C\+K\+\_\+\+I\+N\+I\+T\+\_\+\+N\+UM@{M\+A\+X\+\_\+\+B\+L\+O\+C\+K\+\_\+\+I\+N\+I\+T\+\_\+\+N\+UM}}
\index{M\+A\+X\+\_\+\+B\+L\+O\+C\+K\+\_\+\+I\+N\+I\+T\+\_\+\+N\+UM@{M\+A\+X\+\_\+\+B\+L\+O\+C\+K\+\_\+\+I\+N\+I\+T\+\_\+\+N\+UM}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{M\+A\+X\+\_\+\+B\+L\+O\+C\+K\+\_\+\+I\+N\+I\+T\+\_\+\+N\+UM}{MAX_BLOCK_INIT_NUM}}]{\setlength{\rightskip}{0pt plus 5cm}\#define M\+A\+X\+\_\+\+B\+L\+O\+C\+K\+\_\+\+I\+N\+I\+T\+\_\+\+N\+UM~M\+A\+X\+\_\+\+C\+A\+C\+H\+E\+\_\+\+M\+E\+M\+O\+RY}\hypertarget{dbman_8h_a962b5fc404942e51ae0049dde505590e}{}\label{dbman_8h_a962b5fc404942e51ae0049dde505590e}


How many blocks would be initially allocated. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}


\subsection{Enumeration Type Documentation}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+allocation\+\_\+set\+\_\+mode@{A\+K\+\_\+allocation\+\_\+set\+\_\+mode}}
\index{A\+K\+\_\+allocation\+\_\+set\+\_\+mode@{A\+K\+\_\+allocation\+\_\+set\+\_\+mode}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+allocation\+\_\+set\+\_\+mode}{AK_allocation_set_mode}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf A\+K\+\_\+allocation\+\_\+set\+\_\+mode}}\hypertarget{dbman_8h_af6d80074e26af6570de6d650c1d90851}{}\label{dbman_8h_af6d80074e26af6570de6d650c1d90851}


Different modes to obtain allocation indexes\+: S\+E\+Q\+U\+E\+N\+CE -\/ first found set of sequence indexes U\+P\+P\+ER -\/ set tries to place itself to upper part od allocation table L\+O\+W\+ER -\/ set tries to place itself to lower part od allocation table A\+R\+O\+U\+ND -\/ set tries to place itself around targeted index. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}


\subsection{Function Documentation}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+allocate\+\_\+blocks@{A\+K\+\_\+allocate\+\_\+blocks}}
\index{A\+K\+\_\+allocate\+\_\+blocks@{A\+K\+\_\+allocate\+\_\+blocks}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+allocate\+\_\+blocks(\+F\+I\+L\+E $\ast$db, A\+K\+\_\+block $\ast$block, int From\+Where, int How\+Many)}{AK_allocate_blocks(FILE *db, AK_block *block, int FromWhere, int HowMany)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+allocate\+\_\+blocks (
\begin{DoxyParamCaption}
\item[{F\+I\+LE $\ast$}]{db, }
\item[{{\bf A\+K\+\_\+block} $\ast$}]{block, }
\item[{int}]{From\+Where, }
\item[{int}]{How\+Many}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_ac48b8ab357cefa4ffcc54c348571c1fe}{}\label{dbman_8h_ac48b8ab357cefa4ffcc54c348571c1fe}


Function that allocates new blocks by placing them to appropriate place and then update last initialized index. 

\begin{DoxyAuthor}{Author}
Markus Schatten , rearranged by dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if the file has been written to disk, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+allocationtable\+\_\+dump@{A\+K\+\_\+allocationtable\+\_\+dump}}
\index{A\+K\+\_\+allocationtable\+\_\+dump@{A\+K\+\_\+allocationtable\+\_\+dump}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+allocationtable\+\_\+dump(int zz)}{AK_allocationtable_dump(int zz)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+allocationtable\+\_\+dump (
\begin{DoxyParamCaption}
\item[{int}]{zz}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_acf09d102942a1534d53d89489591af1b}{}\label{dbman_8h_acf09d102942a1534d53d89489591af1b}


Function dumpes allocation table. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
nothing 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+blocktable\+\_\+dump@{A\+K\+\_\+blocktable\+\_\+dump}}
\index{A\+K\+\_\+blocktable\+\_\+dump@{A\+K\+\_\+blocktable\+\_\+dump}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+blocktable\+\_\+dump(int zz)}{AK_blocktable_dump(int zz)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+blocktable\+\_\+dump (
\begin{DoxyParamCaption}
\item[{int}]{zz}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a3956a7198427c0911c2775d382842b98}{}\label{dbman_8h_a3956a7198427c0911c2775d382842b98}


Function dumpes allocation table. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
nothing 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+blocktable\+\_\+flush@{A\+K\+\_\+blocktable\+\_\+flush}}
\index{A\+K\+\_\+blocktable\+\_\+flush@{A\+K\+\_\+blocktable\+\_\+flush}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+blocktable\+\_\+flush()}{AK_blocktable_flush()}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+blocktable\+\_\+flush (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_aef4ddae5253862ad465b91b1e940a71f}{}\label{dbman_8h_aef4ddae5253862ad465b91b1e940a71f}


Function flushes bitmask table to disk. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if the file has been written to disk, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+blocktable\+\_\+get@{A\+K\+\_\+blocktable\+\_\+get}}
\index{A\+K\+\_\+blocktable\+\_\+get@{A\+K\+\_\+blocktable\+\_\+get}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+blocktable\+\_\+get()}{AK_blocktable_get()}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+blocktable\+\_\+get (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_adcfd5252c0eed066034b558df30cc790}{}\label{dbman_8h_adcfd5252c0eed066034b558df30cc790}


Function gets allocation table from disk. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if the file has been taken from disk, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+copy\+\_\+header@{A\+K\+\_\+copy\+\_\+header}}
\index{A\+K\+\_\+copy\+\_\+header@{A\+K\+\_\+copy\+\_\+header}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+copy\+\_\+header(\+A\+K\+\_\+header $\ast$header, int $\ast$blocknum, int num)}{AK_copy_header(AK_header *header, int *blocknum, int num)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+copy\+\_\+header (
\begin{DoxyParamCaption}
\item[{{\bf A\+K\+\_\+header} $\ast$}]{header, }
\item[{int $\ast$}]{blocknum, }
\item[{int}]{num}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_ad4d4a6ea2344a3003ea50930cc0e77b8}{}\label{dbman_8h_ad4d4a6ea2344a3003ea50930cc0e77b8}


Function copy header to blocks. Completely thread-\/safe. 

\begin{DoxyAuthor}{Author}
Nikola Bakoš, updated by Dino Laktašiæ (fixed header B\+UG), refurbished by dv 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em header} & pointer to header provided for copy \\
\hline
{\em blocknum} & pointer to addresses of blocks that header needs to be copied \\
\hline
{\em num} & number of blocks waiting for its header \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of performed header copy 
\end{DoxyReturn}
var to check the number of written blocks

if write of block succeded increase var num\+\_\+blocks, else nothing \index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+create\+\_\+header@{A\+K\+\_\+create\+\_\+header}}
\index{A\+K\+\_\+create\+\_\+header@{A\+K\+\_\+create\+\_\+header}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+create\+\_\+header(char $\ast$name, int type, int integrity, char $\ast$constr\+\_\+name, char $\ast$contr\+\_\+code)}{AK_create_header(char *name, int type, int integrity, char *constr_name, char *contr_code)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf A\+K\+\_\+header}$\ast$ A\+K\+\_\+create\+\_\+header (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{name, }
\item[{int}]{type, }
\item[{int}]{integrity, }
\item[{char $\ast$}]{constr\+\_\+name, }
\item[{char $\ast$}]{contr\+\_\+code}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_adbd8d4f27d7e825392badfcfc4baf968}{}\label{dbman_8h_adbd8d4f27d7e825392badfcfc4baf968}


Function for creating header and initalize integrity, constraint name and constraint code with parameter values of function. 

\begin{DoxyAuthor}{Author}
Matija Novak 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em name} & name of the atribute \\
\hline
{\em type} & type of the atribute \\
\hline
{\em integrity} & standard integrity costraint \\
\hline
{\em constr\+\_\+name} & extra integrity constraint name \\
\hline
{\em contr\+\_\+code} & extra integrity costraint code \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structAK__header}{A\+K\+\_\+header} 
\end{DoxyReturn}
initialize catalog\+\_\+header-\/$>$integrity and catalog\+\_\+header-\/$>$constr\+\_\+name\mbox{[}\mbox{]}\mbox{[}\mbox{]} and catalog\+\_\+header-\/$>$constr\+\_\+code\mbox{[}\mbox{]}\mbox{[}\mbox{]} with data given as functions parameters \index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+delete\+\_\+block@{A\+K\+\_\+delete\+\_\+block}}
\index{A\+K\+\_\+delete\+\_\+block@{A\+K\+\_\+delete\+\_\+block}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+delete\+\_\+block(int address)}{AK_delete_block(int address)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+delete\+\_\+block (
\begin{DoxyParamCaption}
\item[{int}]{address}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a5058a1dd8adfdd5663626492f1d1f257}{}\label{dbman_8h_a5058a1dd8adfdd5663626492f1d1f257}


Function deletes a block by a given block address (resets the header and data). Types, integrities, constraint names, constraint codes are set to \char`\"{}\+A\+K\+\_\+free\char`\"{} values. In tuple dictionary type, address and size are set to F\+R\+E\+E\+\_\+\+I\+NT values. Data of block is set to F\+R\+E\+E\+\_\+\+C\+H\+AR. 

\begin{DoxyAuthor}{Author}
Markus Schatten 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em address} & address of the block to be deleted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if deletion successful, else E\+X\+I\+T\+\_\+\+E\+R\+R\+OR 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+delete\+\_\+extent@{A\+K\+\_\+delete\+\_\+extent}}
\index{A\+K\+\_\+delete\+\_\+extent@{A\+K\+\_\+delete\+\_\+extent}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+delete\+\_\+extent(int begin, int end)}{AK_delete_extent(int begin, int end)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+delete\+\_\+extent (
\begin{DoxyParamCaption}
\item[{int}]{begin, }
\item[{int}]{end}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a1c0ef3161f926bef80f12aa4e0905acd}{}\label{dbman_8h_a1c0ef3161f926bef80f12aa4e0905acd}


Function deletes an extent between begin and end blocks. 

\begin{DoxyAuthor}{Author}
Dejan Samboliæ 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em begin} & address of extent\textquotesingle{}s first block \\
\hline
{\em end} & address of extent\textquotesingle{}s last block \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if extent has been successfully deleted, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+delete\+\_\+segment@{A\+K\+\_\+delete\+\_\+segment}}
\index{A\+K\+\_\+delete\+\_\+segment@{A\+K\+\_\+delete\+\_\+segment}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+delete\+\_\+segment(char $\ast$name, int type)}{AK_delete_segment(char *name, int type)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+delete\+\_\+segment (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{name, }
\item[{int}]{type}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a0a6e9ee9800548168a235c26fcceba71}{}\label{dbman_8h_a0a6e9ee9800548168a235c26fcceba71}
\begin{DoxyAuthor}{Author}
Mislav Èakariæ 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em name} & name of the segment \\
\hline
{\em type} & type of the segment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if extent has been successfully deleted, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+get\+\_\+allocation\+\_\+set@{A\+K\+\_\+get\+\_\+allocation\+\_\+set}}
\index{A\+K\+\_\+get\+\_\+allocation\+\_\+set@{A\+K\+\_\+get\+\_\+allocation\+\_\+set}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+get\+\_\+allocation\+\_\+set(int $\ast$bitsetbs, int from\+Where, int gaplength, int num, A\+K\+\_\+allocation\+\_\+set\+\_\+mode mode, int target)}{AK_get_allocation_set(int *bitsetbs, int fromWhere, int gaplength, int num, AK_allocation_set_mode mode, int target)}}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ A\+K\+\_\+get\+\_\+allocation\+\_\+set (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{bitsetbs, }
\item[{int}]{from\+Where, }
\item[{int}]{gaplength, }
\item[{int}]{num, }
\item[{{\bf A\+K\+\_\+allocation\+\_\+set\+\_\+mode}}]{mode, }
\item[{int}]{target}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a377b7d3e346a2cbe608d468f4274cda8}{}\label{dbman_8h_a377b7d3e346a2cbe608d468f4274cda8}


Function prepare demanded sets from allocation table. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em bitset} & int pointer, cointainer for bit set \\
\hline
{\em from\+Where} & has meaning just in S\+E\+Q\+U\+E\+N\+CE case. It describes from which address searching have to start. \\
\hline
{\em gaplength} & tells how many used blocks could be tolerated in bitset \\
\hline
{\em num} & Tells how many A\+K\+\_\+free blocks has been needed \\
\hline
{\em mode} & Defines how to obtain set of indexes to A\+K\+\_\+free addresses \\
\hline
{\em target} & has meaning just in case mode=A\+R\+O\+U\+ND\+: set must be as much as possible close to target from both sides \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to integer indexes field with prepared set. If it , for any reason, is not possible set has F\+R\+E\+E\+\_\+\+I\+NT fullfilment. 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+get\+\_\+extent@{A\+K\+\_\+get\+\_\+extent}}
\index{A\+K\+\_\+get\+\_\+extent@{A\+K\+\_\+get\+\_\+extent}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+get\+\_\+extent(int start\+\_\+address, int desired\+\_\+size, A\+K\+\_\+allocation\+\_\+set\+\_\+mode $\ast$mode, int border, int target, A\+K\+\_\+header $\ast$header, int gl)}{AK_get_extent(int start_address, int desired_size, AK_allocation_set_mode *mode, int border, int target, AK_header *header, int gl)}}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ A\+K\+\_\+get\+\_\+extent (
\begin{DoxyParamCaption}
\item[{int}]{start\+\_\+address, }
\item[{int}]{desired\+\_\+size, }
\item[{{\bf A\+K\+\_\+allocation\+\_\+set\+\_\+mode} $\ast$}]{mode, }
\item[{int}]{border, }
\item[{int}]{target, }
\item[{{\bf A\+K\+\_\+header} $\ast$}]{header, }
\item[{int}]{gl}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a9525b11c47b5825abb4956add526623c}{}\label{dbman_8h_a9525b11c47b5825abb4956add526623c}


Function alocates new extent of blocks. Number of blocks is not ordered as well as a way of search for them. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em start\+\_\+address} & address (block number) to start searching for sufficient space \\
\hline
{\em desired\+\_\+size} & number of desired blocks \\
\hline
{\em A\+K\+\_\+allocation\+\_\+set\+\_\+mode} & a way of trying to fing A\+K\+\_\+free space. Can be one of\+: allocation\+S\+E\+Q\+U\+E\+N\+CE, allocation\+U\+P\+P\+ER, allocation\+L\+O\+W\+ER, allocation\+A\+R\+O\+U\+ND \\
\hline
{\em border} & number of allocated blocks gap \\
\hline
{\em target} & block address around which other blocks have to be searched \\
\hline
{\em header} & pointer to header that should be written to the new extent (all blocks) \\
\hline
{\em int} & gl gap size \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to set of alocated block addresses 
\end{DoxyReturn}
vars for loop \mbox{[}for\mbox{]}

if some blocks are not succesfully allocated, which means that the extend allocation has F\+A\+I\+L\+ED \index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+increase\+\_\+extent@{A\+K\+\_\+increase\+\_\+extent}}
\index{A\+K\+\_\+increase\+\_\+extent@{A\+K\+\_\+increase\+\_\+extent}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+increase\+\_\+extent(int start\+\_\+address, int add\+\_\+size, A\+K\+\_\+allocation\+\_\+set\+\_\+mode $\ast$mode, int border, int target, A\+K\+\_\+header $\ast$header, int gl)}{AK_increase_extent(int start_address, int add_size, AK_allocation_set_mode *mode, int border, int target, AK_header *header, int gl)}}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ A\+K\+\_\+increase\+\_\+extent (
\begin{DoxyParamCaption}
\item[{int}]{start\+\_\+address, }
\item[{int}]{add\+\_\+size, }
\item[{{\bf A\+K\+\_\+allocation\+\_\+set\+\_\+mode} $\ast$}]{mode, }
\item[{int}]{border, }
\item[{int}]{target, }
\item[{{\bf A\+K\+\_\+header} $\ast$}]{header, }
\item[{int}]{gl}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a9411aae916046fdd8e53ed1760a58b6d}{}\label{dbman_8h_a9411aae916046fdd8e53ed1760a58b6d}


Function alocates new blocks for increasing extent size. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em start\+\_\+address} & first address of extent that is subject of increasing \\
\hline
{\em add\+\_\+size} & number how many new blocks is to be added to existing extent \\
\hline
{\em A\+K\+\_\+allocation\+\_\+set\+\_\+mode} & a way of trying to fing A\+K\+\_\+free space. Can be one of\+: allocation\+S\+E\+Q\+U\+E\+N\+CE, allocation\+U\+P\+P\+ER, allocation\+L\+O\+W\+ER, allocation\+A\+R\+O\+U\+ND \\
\hline
{\em border} & number of allocated blocks gap \\
\hline
{\em target} & block address around which other blocks have to be searched \\
\hline
{\em header} & pointer to header that should be written to the new extent (all blocks) \\
\hline
{\em int} & gl gap size \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to set of alocated block addresses 
\end{DoxyReturn}
vars for loop \mbox{[}for\mbox{]} \index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+init\+\_\+allocation\+\_\+table@{A\+K\+\_\+init\+\_\+allocation\+\_\+table}}
\index{A\+K\+\_\+init\+\_\+allocation\+\_\+table@{A\+K\+\_\+init\+\_\+allocation\+\_\+table}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+init\+\_\+allocation\+\_\+table()}{AK_init_allocation_table()}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+init\+\_\+allocation\+\_\+table (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_aee0b4429858370953a410c6fb5b9ec92}{}\label{dbman_8h_aee0b4429858370953a410c6fb5b9ec92}


Function that initializes allocation table, write it to disk and cache in memory. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if the file has been written to disk, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+init\+\_\+block@{A\+K\+\_\+init\+\_\+block}}
\index{A\+K\+\_\+init\+\_\+block@{A\+K\+\_\+init\+\_\+block}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+init\+\_\+block()}{AK_init_block()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf A\+K\+\_\+block}$\ast$ A\+K\+\_\+init\+\_\+block (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a402f984ce7298e193a2a9c5dc5d6b901}{}\label{dbman_8h_a402f984ce7298e193a2a9c5dc5d6b901}


Function that initializes new block. 

\begin{DoxyAuthor}{Author}
Markus Schatten , rearranged by dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
pointer to block allocated in memory 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+init\+\_\+db\+\_\+file@{A\+K\+\_\+init\+\_\+db\+\_\+file}}
\index{A\+K\+\_\+init\+\_\+db\+\_\+file@{A\+K\+\_\+init\+\_\+db\+\_\+file}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+init\+\_\+db\+\_\+file(int size)}{AK_init_db_file(int size)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+init\+\_\+db\+\_\+file (
\begin{DoxyParamCaption}
\item[{int}]{size}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a7cacca7e9aebff2aee36f85632e5c35e}{}\label{dbman_8h_a7cacca7e9aebff2aee36f85632e5c35e}


Function that initializes a new database file named D\+B\+\_\+\+F\+I\+LE. It opens database file. New block is allocated. In this block type of header is set to F\+R\+E\+E\+\_\+\+I\+NT, attribute names are set to F\+R\+E\+E\+\_\+\+C\+H\+AR, integrities are set to F\+R\+E\+E\+\_\+\+I\+NT, constraint names are set to F\+R\+E\+E\+\_\+\+C\+H\+AR, constraint names and codes are set to F\+R\+E\+E\+\_\+\+C\+H\+AR. Type, address and size of tuples are set to F\+R\+E\+E\+\_\+\+I\+NT. Data in block is set to F\+R\+E\+E\+\_\+\+C\+H\+AR. Type of block is B\+L\+O\+C\+K\+\_\+\+T\+Y\+P\+E\+\_\+\+F\+R\+EE, it is not chained and id of last tuple is 0. 

\begin{DoxyAuthor}{Author}
Markus Schatten 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em size} & size of new file in in blocks \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if the file has been written to disk, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+init\+\_\+disk\+\_\+manager@{A\+K\+\_\+init\+\_\+disk\+\_\+manager}}
\index{A\+K\+\_\+init\+\_\+disk\+\_\+manager@{A\+K\+\_\+init\+\_\+disk\+\_\+manager}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+init\+\_\+disk\+\_\+manager()}{AK_init_disk_manager()}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+init\+\_\+disk\+\_\+manager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a7e7d6a4c56ce0c15b59217a3607db06e}{}\label{dbman_8h_a7e7d6a4c56ce0c15b59217a3607db06e}
\begin{DoxyAuthor}{Author}
Markus Schatten 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
Function that calls functions \hyperlink{dbman_8c_a7cacca7e9aebff2aee36f85632e5c35e}{A\+K\+\_\+init\+\_\+db\+\_\+file()} and \hyperlink{dbman_8c_af99cdc5c8456ad5ff87fb542d030c4d6}{A\+K\+\_\+init\+\_\+system\+\_\+catalog()} to initialize disk manager. It also calls A\+K\+\_\+allocate\+\_\+array\+\_\+currently\+\_\+accessed\+\_\+blocks() to allocate memory needed for thread-\/safe reading and writing to disk. 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+init\+\_\+system\+\_\+catalog@{A\+K\+\_\+init\+\_\+system\+\_\+catalog}}
\index{A\+K\+\_\+init\+\_\+system\+\_\+catalog@{A\+K\+\_\+init\+\_\+system\+\_\+catalog}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+init\+\_\+system\+\_\+catalog()}{AK_init_system_catalog()}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+init\+\_\+system\+\_\+catalog (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_af99cdc5c8456ad5ff87fb542d030c4d6}{}\label{dbman_8h_af99cdc5c8456ad5ff87fb542d030c4d6}


Function initializes the system catalog. Headers for system tables are defined. Segments for those system tables are allocated. Above function \hyperlink{dbman_8c_af4c050534ddf6dcf1cba09987424ff76}{A\+K\+\_\+register\+\_\+system\+\_\+tables()} to register system tables. 

\begin{DoxyAuthor}{Author}
Miroslav Policki 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if the system catalog has been successfully initialized, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog@{A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog}}
\index{A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog@{A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog(int relation, int attribute, int index, int view, int sequence, int function, int function\+\_\+arguments, int trigger, int trigger\+\_\+conditions, int db, int db\+\_\+obj, int user, int group, int user\+\_\+group, int user\+\_\+right, int group\+\_\+right, int constraint, int constraint\+Null, int constraint\+Check, int constraint\+Unique, int reference)}{AK_init_system_tables_catalog(int relation, int attribute, int index, int view, int sequence, int function, int function_arguments, int trigger, int trigger_conditions, int db, int db_obj, int user, int group, int user_group, int user_right, int group_right, int constraint, int constraintNull, int constraintCheck, int constraintUnique, int reference)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog (
\begin{DoxyParamCaption}
\item[{int}]{relation, }
\item[{int}]{attribute, }
\item[{int}]{index, }
\item[{int}]{view, }
\item[{int}]{sequence, }
\item[{int}]{function, }
\item[{int}]{function\+\_\+arguments, }
\item[{int}]{trigger, }
\item[{int}]{trigger\+\_\+conditions, }
\item[{int}]{db, }
\item[{int}]{db\+\_\+obj, }
\item[{int}]{user, }
\item[{int}]{group, }
\item[{int}]{user\+\_\+group, }
\item[{int}]{user\+\_\+right, }
\item[{int}]{group\+\_\+right, }
\item[{int}]{constraint, }
\item[{int}]{constraint\+Null, }
\item[{int}]{constraint\+Check, }
\item[{int}]{constraint\+Unique, }
\item[{int}]{reference}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_ac48430852cddc2cc7b79dd2775212b10}{}\label{dbman_8h_ac48430852cddc2cc7b79dd2775212b10}


Function initialises the sytem table catalog and writes the result in first (0) block in db\+\_\+file. Catalog block, catalog header name, catalog header address are allocated. Address, type, chained\+\_\+with and A\+K\+\_\+free\+\_\+space attributes are initialized. Names of various database elements are written in block. 

\begin{DoxyAuthor}{Author}
Matija Novak 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em relation} & address of system table of relation in db\+\_\+file \\
\hline
{\em attribute} & address of system table of attribute in db\+\_\+file \\
\hline
{\em index} & address of system table of index in db\+\_\+file \\
\hline
{\em view} & address of system table of view in db\+\_\+file \\
\hline
{\em sequence} & address of system table of sequence in db\+\_\+file \\
\hline
{\em function} & address of system table of function in db\+\_\+file \\
\hline
{\em function\+\_\+arguments} & address of system table of function\+\_\+arguments in db\+\_\+file \\
\hline
{\em trigger} & address of system table of trigger in db\+\_\+file \\
\hline
{\em trigger\+\_\+conditions} & address of system table of trigger\+\_\+conditions in db\+\_\+file \\
\hline
{\em db} & address of system table of db in db\+\_\+file \\
\hline
{\em db\+\_\+obj} & address of system table of db\+\_\+obj in db\+\_\+file \\
\hline
{\em user} & address of system table of user in db\+\_\+file \\
\hline
{\em group} & address of system table of group in db\+\_\+file \\
\hline
{\em user\+\_\+group} & address of system table of users associated with groups in db\+\_\+file \\
\hline
{\em user\+\_\+right} & address of system table of user right in db\+\_\+file \\
\hline
{\em group\+\_\+right} & address of system table of group right in db\+\_\+file \\
\hline
{\em constraint} & address of system table of constraint in db\+\_\+file \\
\hline
{\em constraint\+Null} & address of system table of constraint\+Null in db\+\_\+file \\
\hline
{\em constraint\+Check} & system table address for check constraint \\
\hline
{\em reference} & address of system table of reference in db\+\_\+file \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if initialization was succesful if not returns E\+X\+I\+T\+\_\+\+E\+R\+R\+OR 
\end{DoxyReturn}
first header attribute of catalog\+\_\+block

second attribute of catalog\+\_\+block

initialize other elements of block (adress, type, chained\+\_\+with, A\+K\+\_\+free\+\_\+space)

using as an address for the first A\+K\+\_\+free space in block-\/$>$data

merge catalog\+\_\+heder with heders created before

insert data and tuple\+\_\+dict in block

call function for writing the block on the first place in the file (ie. first block is on position zero) \index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+insert\+\_\+entry@{A\+K\+\_\+insert\+\_\+entry}}
\index{A\+K\+\_\+insert\+\_\+entry@{A\+K\+\_\+insert\+\_\+entry}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+insert\+\_\+entry(\+A\+K\+\_\+block $\ast$block\+\_\+address, int type, void $\ast$entry\+\_\+data, int i)}{AK_insert_entry(AK_block *block_address, int type, void *entry_data, int i)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+insert\+\_\+entry (
\begin{DoxyParamCaption}
\item[{{\bf A\+K\+\_\+block} $\ast$}]{block\+\_\+address, }
\item[{int}]{type, }
\item[{void $\ast$}]{entry\+\_\+data, }
\item[{int}]{i}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a0f011234546a9f1cc751a0d08036b131}{}\label{dbman_8h_a0f011234546a9f1cc751a0d08036b131}


Function for inserting entry in tuple\+\_\+dict and data of a block. Address, type and size of catalog\+\_\+tuple\+\_\+dict are set. Free space of block is also set. 

\begin{DoxyAuthor}{Author}
Matija Novak 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em block\+\_\+adress} & adress of a block in which we want insert data \\
\hline
{\em type} & type of entry\+\_\+data \\
\hline
{\em entry\+\_\+data} & (char) data which is inserted, can be int but must first be converted to char \\
\hline
{\em i} & (int) adress in tuple\+\_\+dict array (example block\+\_\+address-\/$>$tuple\+\_\+dict\mbox{[}i\mbox{]}) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
No return value because it gets the address of an block like a function parameter and works directly with the orginal block 
\end{DoxyReturn}
using strlen becuse sizeof(entry\+\_\+data) is always 4 copy data into bloc-\/$>$data on start position bloc-\/$>$A\+K\+\_\+free\+\_\+space

address of entry data in block-\/$>$data

calculate next A\+K\+\_\+free space for the next entry data \begin{DoxyVerb}                                                              sizeof(entry_data)+1);///(sizeof(int));
\end{DoxyVerb}
 no need for \char`\"{}+strlen(entry\+\_\+data)\char`\"{} while \char`\"{}+1\char`\"{} is like \char`\"{}new line\char`\"{}

type of entry data

size of entry data

copy tuple\+\_\+dict to block-\/$>$tuple\+\_\+dict\mbox{[}i\mbox{]} must use \& becouse tuple\+\_\+dict\mbox{[}i\mbox{]} is value and catalog\+\_\+tuple\+\_\+dict adress \index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+memset\+\_\+int@{A\+K\+\_\+memset\+\_\+int}}
\index{A\+K\+\_\+memset\+\_\+int@{A\+K\+\_\+memset\+\_\+int}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+memset\+\_\+int(void $\ast$block, int value, size\+\_\+t num)}{AK_memset_int(void *block, int value, size_t num)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+memset\+\_\+int (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{block, }
\item[{int}]{value, }
\item[{size\+\_\+t}]{num}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a3157bc3da79c19192a915acc1235bad0}{}\label{dbman_8h_a3157bc3da79c19192a915acc1235bad0}


Function that sets the first num ints of a block of memory to the specified value. 

\begin{DoxyAuthor}{Author}
Miroslav Policki 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em block} & pointer to the block of memory to fill \\
\hline
{\em value} & int value to be set \\
\hline
{\em num} & number of ints in the block of memory to be set \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
No return value 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+new\+\_\+extent@{A\+K\+\_\+new\+\_\+extent}}
\index{A\+K\+\_\+new\+\_\+extent@{A\+K\+\_\+new\+\_\+extent}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+new\+\_\+extent(int start\+\_\+address, int old\+\_\+size, int extent\+\_\+type, A\+K\+\_\+header $\ast$header)}{AK_new_extent(int start_address, int old_size, int extent_type, AK_header *header)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+new\+\_\+extent (
\begin{DoxyParamCaption}
\item[{int}]{start\+\_\+address, }
\item[{int}]{old\+\_\+size, }
\item[{int}]{extent\+\_\+type, }
\item[{{\bf A\+K\+\_\+header} $\ast$}]{header}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a1ff7d6ea92a45cda91ff2063043900a1}{}\label{dbman_8h_a1ff7d6ea92a45cda91ff2063043900a1}


Function alocates new extent of blocks. If argument \char`\"{}old\+\_\+size\char`\"{} is 0 than size of extent is I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE. Otherwise, resize factor is set according to type of extent. If writing of block is successful, number of blocks is incremented. 

\begin{DoxyAuthor}{Author}
Nikola Bakoš, updated by Dino Laktašiæ (fixed header B\+UG), refurbished by dv 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em start\+\_\+address} & address (block number) to start searching for sufficient space \\
\hline
{\em old\+\_\+size} & size of previous extent in same segment (in blocks) \\
\hline
{\em extent\+\_\+type} & type of extent (can be one of\+: S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+S\+Y\+S\+T\+E\+M\+\_\+\+T\+A\+B\+LE, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+A\+B\+LE, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+N\+D\+EX, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+R\+A\+N\+S\+A\+C\+T\+I\+ON, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+E\+MP \\
\hline
{\em header} & pointer to header that should be written to the new extent (all blocks) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
address (block number) of new extent if successful, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
var -\/ How much of space is required for extent

vars for loop \mbox{[}for\mbox{]}

if the old\+\_\+size is 0 then the size of new extent is I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE

if some blocks are not succesfully allocated, which means that the extend allocation has F\+A\+I\+L\+ED \index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+new\+\_\+segment@{A\+K\+\_\+new\+\_\+segment}}
\index{A\+K\+\_\+new\+\_\+segment@{A\+K\+\_\+new\+\_\+segment}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+new\+\_\+segment(char $\ast$name, int type, A\+K\+\_\+header $\ast$header)}{AK_new_segment(char *name, int type, AK_header *header)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+new\+\_\+segment (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{name, }
\item[{int}]{type, }
\item[{{\bf A\+K\+\_\+header} $\ast$}]{header}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a79e7998e69e2910528f7ef258469b2be}{}\label{dbman_8h_a79e7998e69e2910528f7ef258469b2be}


Function that allocates new segment of extents. In this phase of implementation, only extents containing I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE blocks can be allocated. If extent is successfully allocated, number of allocated extents is incremented and function goes to next block after allocated extent. Otherwise, function moves to I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE blocks. In that way function gets either first block of new extent or some block in that extent which will not be A\+K\+\_\+free. 

\begin{DoxyAuthor}{Author}
Tomislav Fotak, refurbished by dv 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em name} & (character pointer) name of segment \\
\hline
{\em type} & segment type (possible values\+: S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+S\+Y\+S\+T\+E\+M\+\_\+\+T\+A\+B\+LE, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+A\+B\+LE, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+N\+D\+EX, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+R\+A\+N\+S\+A\+C\+T\+I\+ON, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+E\+MP) \\
\hline
{\em header} & (header pointer) pointer to header that should be written to the new extent (all blocks) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS for success or E\+X\+I\+T\+\_\+\+E\+R\+R\+OR if some error occurs 
\end{DoxyReturn}
start address for segment because we can not allocate segment in block 0 \index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+print\+\_\+block@{A\+K\+\_\+print\+\_\+block}}
\index{A\+K\+\_\+print\+\_\+block@{A\+K\+\_\+print\+\_\+block}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+print\+\_\+block(\+A\+K\+\_\+block $\ast$block, int num, char $\ast$gg, F\+I\+L\+E $\ast$fpp)}{AK_print_block(AK_block *block, int num, char *gg, FILE *fpp)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+print\+\_\+block (
\begin{DoxyParamCaption}
\item[{{\bf A\+K\+\_\+block} $\ast$}]{block, }
\item[{int}]{num, }
\item[{char $\ast$}]{gg, }
\item[{F\+I\+LE $\ast$}]{fpp}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a3fcca519b1dbe309c683d64b0e955dca}{}\label{dbman_8h_a3fcca519b1dbe309c683d64b0e955dca}


Function that dumps block. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
nothing 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+read\+\_\+block@{A\+K\+\_\+read\+\_\+block}}
\index{A\+K\+\_\+read\+\_\+block@{A\+K\+\_\+read\+\_\+block}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+read\+\_\+block(int address)}{AK_read_block(int address)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf A\+K\+\_\+block}$\ast$ A\+K\+\_\+read\+\_\+block (
\begin{DoxyParamCaption}
\item[{int}]{address}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a2c880db7cf4f8332ae7e93c6b71cc911}{}\label{dbman_8h_a2c880db7cf4f8332ae7e93c6b71cc911}


Function that reads a block at a given address (block number less than db\+\_\+file\+\_\+size). New block is allocated. Database file is opened. Position is set to provided address block. At the end function reads file from that position. Completely thread-\/safe. 

\begin{DoxyAuthor}{Author}
Markus Schatten, updated dv and Domagoj Šitum (thread-\/safe enabled) 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em address} & block number (address) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to block allocated in memory 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing@{A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing}}
\index{A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing@{A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing(void $\ast$address)}{AK_read_block_for_testing(void *address)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{address}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a5499694bd97b104560d14ef70abe2c73}{}\label{dbman_8h_a5499694bd97b104560d14ef70abe2c73}


This function is only for testing. It has to be there, because pthread\+\_\+create only accepts void$\ast$ function\+\_\+name (void $\ast$) function format. So A\+K\+\_\+read\+\_\+block is no-\/go for pthread\+\_\+create. 

\begin{DoxyAuthor}{Author}
Domagoj Šitum 
\end{DoxyAuthor}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+register\+\_\+system\+\_\+tables@{A\+K\+\_\+register\+\_\+system\+\_\+tables}}
\index{A\+K\+\_\+register\+\_\+system\+\_\+tables@{A\+K\+\_\+register\+\_\+system\+\_\+tables}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+register\+\_\+system\+\_\+tables(int relation, int attribute, int index, int view, int sequence, int function, int function\+\_\+arguments, int trigger, int trigger\+\_\+conditions, int db, int db\+\_\+obj, int user, int group, int user\+\_\+group, int user\+\_\+right, int group\+\_\+right, int constraint, int constraint\+Null, int constraint\+Check, int constraint\+Unique, int reference)}{AK_register_system_tables(int relation, int attribute, int index, int view, int sequence, int function, int function_arguments, int trigger, int trigger_conditions, int db, int db_obj, int user, int group, int user_group, int user_right, int group_right, int constraint, int constraintNull, int constraintCheck, int constraintUnique, int reference)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+register\+\_\+system\+\_\+tables (
\begin{DoxyParamCaption}
\item[{int}]{relation, }
\item[{int}]{attribute, }
\item[{int}]{index, }
\item[{int}]{view, }
\item[{int}]{sequence, }
\item[{int}]{function, }
\item[{int}]{function\+\_\+arguments, }
\item[{int}]{trigger, }
\item[{int}]{trigger\+\_\+conditions, }
\item[{int}]{db, }
\item[{int}]{db\+\_\+obj, }
\item[{int}]{user, }
\item[{int}]{group, }
\item[{int}]{user\+\_\+group, }
\item[{int}]{user\+\_\+right, }
\item[{int}]{group\+\_\+right, }
\item[{int}]{constraint, }
\item[{int}]{constraint\+Null, }
\item[{int}]{constraint\+Check, }
\item[{int}]{constraint\+Unique, }
\item[{int}]{reference}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_af4c050534ddf6dcf1cba09987424ff76}{}\label{dbman_8h_af4c050534ddf6dcf1cba09987424ff76}


Function that registers system tables. Block at the given address is read. Various data from function arguments are written in block about different database elements. 

\begin{DoxyAuthor}{Author}
Unknown 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em relation} & relation in database \\
\hline
{\em attribute} & attribute in databse \\
\hline
{\em index} & index in database \\
\hline
{\em view} & view in database \\
\hline
{\em sequence} & sequence in database \\
\hline
{\em function} & function in database \\
\hline
{\em function\+\_\+arguments} & functional\+\_\+arguments in databse \\
\hline
{\em trigger} & trigger in database \\
\hline
{\em trigger\+\_\+conditions} & trigger conditions in databse \\
\hline
{\em db} & database \\
\hline
{\em db\+\_\+obj} & database object \\
\hline
{\em user} & user in database \\
\hline
{\em group} & group in database \\
\hline
{\em user\+\_\+group} & user associated with group in database \\
\hline
{\em user\+\_\+right} & user right in database \\
\hline
{\em group\+\_\+right} & group right in database \\
\hline
{\em constraint} & constraint in database \\
\hline
{\em constraint\+Null} & Null constraint in database \\
\hline
{\em constraint\+Check} & Check constraint in database \\
\hline
{\em reference} & reference database \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test@{A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test}}
\index{A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test@{A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test()}{AK_thread_safe_block_access_test()}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a41ad69e55d09ab4aa2bec6dd34805367}{}\label{dbman_8h_a41ad69e55d09ab4aa2bec6dd34805367}


This function tests thread safe reading and writing to blocks. There is N writing and N reading threads, which are going through iterations. Each reading thread should read the data (character) that was set by last writing thread. 

\begin{DoxyAuthor}{Author}
Domagoj Šitum 
\end{DoxyAuthor}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+write\+\_\+block@{A\+K\+\_\+write\+\_\+block}}
\index{A\+K\+\_\+write\+\_\+block@{A\+K\+\_\+write\+\_\+block}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+write\+\_\+block(\+A\+K\+\_\+block $\ast$block)}{AK_write_block(AK_block *block)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+write\+\_\+block (
\begin{DoxyParamCaption}
\item[{{\bf A\+K\+\_\+block} $\ast$}]{block}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a222ea31aa276d52e464137a3b144f78a}{}\label{dbman_8h_a222ea31aa276d52e464137a3b144f78a}


Function writes a block to DB file. Database file is opened. Position is set to provided address block. Block is written to provided address. Completely thread-\/safe. 

\begin{DoxyAuthor}{Author}
Markus Schatten, updated by Domagoj Šitum (thread-\/safe enabled) 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em block} & poiner to block allocated in memory to write \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if successful, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing@{A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing}}
\index{A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing@{A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing(void $\ast$block)}{AK_write_block_for_testing(void *block)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{block}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_a0558e034eeed865a1c855de5cfad20ef}{}\label{dbman_8h_a0558e034eeed865a1c855de5cfad20ef}


This function is only for testing. It has to be there, because pthread\+\_\+create only accepts void$\ast$ function\+\_\+name (void $\ast$) function format. So A\+K\+\_\+write\+\_\+block is no-\/go for pthread\+\_\+create. 

\begin{DoxyAuthor}{Author}
Domagoj Šitum 
\end{DoxyAuthor}
\index{dbman.\+h@{dbman.\+h}!fsize@{fsize}}
\index{fsize@{fsize}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{fsize(\+F\+I\+L\+E $\ast$fp)}{fsize(FILE *fp)}}]{\setlength{\rightskip}{0pt plus 5cm}int fsize (
\begin{DoxyParamCaption}
\item[{F\+I\+LE $\ast$}]{fp}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8h_adbc6978517271fbd48a004cb039ac6c1}{}\label{dbman_8h_adbc6978517271fbd48a004cb039ac6c1}


Helper function to determine file size. 

\begin{DoxyReturn}{Returns}
file size 
\end{DoxyReturn}


\subsection{Variable Documentation}
\index{dbman.\+h@{dbman.\+h}!A\+K\+\_\+allocationbit@{A\+K\+\_\+allocationbit}}
\index{A\+K\+\_\+allocationbit@{A\+K\+\_\+allocationbit}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+allocationbit}{AK_allocationbit}}]{\setlength{\rightskip}{0pt plus 5cm}A\+K\+\_\+allocationbit}\hypertarget{dbman_8h_ab48e0673901ef82fcfc43f98627111df}{}\label{dbman_8h_ab48e0673901ef82fcfc43f98627111df}


Global variable that holds allocation bit-\/vector. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\index{dbman.\+h@{dbman.\+h}!db@{db}}
\index{db@{db}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{db}{db}}]{\setlength{\rightskip}{0pt plus 5cm}db}\hypertarget{dbman_8h_a89a7f6028a19c3dc081cc5f16eb53891}{}\label{dbman_8h_a89a7f6028a19c3dc081cc5f16eb53891}


Variable that defines the DB file file handle. 

\begin{DoxyAuthor}{Author}
Markus Schatten 
\end{DoxyAuthor}
\index{dbman.\+h@{dbman.\+h}!db\+\_\+file\+\_\+size@{db\+\_\+file\+\_\+size}}
\index{db\+\_\+file\+\_\+size@{db\+\_\+file\+\_\+size}!dbman.\+h@{dbman.\+h}}
\subsubsection[{\texorpdfstring{db\+\_\+file\+\_\+size}{db_file_size}}]{\setlength{\rightskip}{0pt plus 5cm}db\+\_\+file\+\_\+size}\hypertarget{dbman_8h_afec6731df4a8f57725504d170bbec2d0}{}\label{dbman_8h_afec6731df4a8f57725504d170bbec2d0}


Variable that defines the size of the DB file (in blocks) 

\begin{DoxyAuthor}{Author}
Markus Schatten 
\end{DoxyAuthor}
