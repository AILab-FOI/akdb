<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Kalashnikov DBBBB: sql/cs/reference.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalashnikov DBBBB
   &#160;<span id="projectnumber">2.2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_5bd71961b401a432086d0fb290a87f3f.html">sql</a></li><li class="navelem"><a class="el" href="dir_139c299d75702e59deac57484ebaa7d8.html">cs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">reference.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="dbman_8h_source.html">../../dm/dbman.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="table_8h_source.html">../../file/table.h</a>&quot;</code><br />
<code>#include &quot;../../auxi/mempro.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for reference.h:</div>
<div class="dyncontent">
<div class="center"><img src="reference_8h__incl.png" border="0" usemap="#sql_2cs_2reference_8h" alt=""/></div>
<!-- MAP 0 -->
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="reference_8h__dep__incl.png" border="0" usemap="#sql_2cs_2reference_8hdep" alt=""/></div>
<!-- MAP 1 -->
</div>
</div>
<p><a href="reference_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAK__ref__item.html">AK_ref_item</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that represents reference item. It contains of table, attributes, parent table and it's attributes, number of attributes, constraint and type of reference.  <a href="structAK__ref__item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a16fa9e833db3ea311a33f8f886faaeca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16fa9e833db3ea311a33f8f886faaeca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#a16fa9e833db3ea311a33f8f886faaeca">REF_TYPE_NONE</a>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:a16fa9e833db3ea311a33f8f886faaeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant declaring none reference type. <br /></td></tr>
<tr class="separator:a16fa9e833db3ea311a33f8f886faaeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f60a580c7b5104d851df9f64523439e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f60a580c7b5104d851df9f64523439e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#a3f60a580c7b5104d851df9f64523439e">REF_TYPE_SET_NULL</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a3f60a580c7b5104d851df9f64523439e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant declaring set null reference type. <br /></td></tr>
<tr class="separator:a3f60a580c7b5104d851df9f64523439e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab683b166173b43a5f4720875815b4ef5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#ab683b166173b43a5f4720875815b4ef5">REF_TYPE_NO_ACTION</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ab683b166173b43a5f4720875815b4ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant declaring no action reference type.  <a href="#ab683b166173b43a5f4720875815b4ef5">More...</a><br /></td></tr>
<tr class="separator:ab683b166173b43a5f4720875815b4ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a098b4ecd7d12a51c514a772d8de13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29a098b4ecd7d12a51c514a772d8de13"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REF_TYPE_CASCADE</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a29a098b4ecd7d12a51c514a772d8de13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4cfbd066207dc5d883d127ba3d43bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d4cfbd066207dc5d883d127ba3d43bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#a9d4cfbd066207dc5d883d127ba3d43bc">REF_TYPE_RESTRICT</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a9d4cfbd066207dc5d883d127ba3d43bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant declaring restrict reference type. <br /></td></tr>
<tr class="separator:a9d4cfbd066207dc5d883d127ba3d43bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53c34e0a0d74cad52736788088e7079"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af53c34e0a0d74cad52736788088e7079"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#af53c34e0a0d74cad52736788088e7079">REF_TYPE_SET_DEFAULT</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:af53c34e0a0d74cad52736788088e7079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant declaring set default reference type. <br /></td></tr>
<tr class="separator:af53c34e0a0d74cad52736788088e7079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1892ca5d8fd96ba1813befff40c84ebd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1892ca5d8fd96ba1813befff40c84ebd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#a1892ca5d8fd96ba1813befff40c84ebd">MAX_REFERENCE_ATTRIBUTES</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:a1892ca5d8fd96ba1813befff40c84ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant declaring maximum number of reference attributes. <br /></td></tr>
<tr class="separator:a1892ca5d8fd96ba1813befff40c84ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe41d26ee4ca5bfb12ffeb14b6d6f72a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe41d26ee4ca5bfb12ffeb14b6d6f72a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#abe41d26ee4ca5bfb12ffeb14b6d6f72a">MAX_CHILD_CONSTRAINTS</a>&#160;&#160;&#160;20</td></tr>
<tr class="memdesc:abe41d26ee4ca5bfb12ffeb14b6d6f72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant declaring maximum number of child constraints. <br /></td></tr>
<tr class="separator:abe41d26ee4ca5bfb12ffeb14b6d6f72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5642d4715910a224460ee3ad66e866e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#a5642d4715910a224460ee3ad66e866e6">AK_add_reference</a> (char *childTable, char *childAttNames[], char *parentTable, char *parentAttNames[], int attNum, char *constraintName, int type)</td></tr>
<tr class="memdesc:a5642d4715910a224460ee3ad66e866e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function adds a reference for a group of attributes over a given table to a group of attributes over another table with a given constraint name..  <a href="#a5642d4715910a224460ee3ad66e866e6">More...</a><br /></td></tr>
<tr class="separator:a5642d4715910a224460ee3ad66e866e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649ec65739751d5504693e55184a98a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAK__ref__item.html">AK_ref_item</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#a649ec65739751d5504693e55184a98a9">AK_get_reference</a> (char *tableName, char *constraintName)</td></tr>
<tr class="memdesc:a649ec65739751d5504693e55184a98a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function reads a reference entry from system table.  <a href="#a649ec65739751d5504693e55184a98a9">More...</a><br /></td></tr>
<tr class="separator:a649ec65739751d5504693e55184a98a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b180aec5b34a0d6341ca689931521cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#a4b180aec5b34a0d6341ca689931521cc">AK_reference_check_attribute</a> (char *tableName, char *attribute, char *value)</td></tr>
<tr class="memdesc:a4b180aec5b34a0d6341ca689931521cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function checks referential integrity for one attribute.  <a href="#a4b180aec5b34a0d6341ca689931521cc">More...</a><br /></td></tr>
<tr class="separator:a4b180aec5b34a0d6341ca689931521cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e7e910e26cb4e1a3e6eb387e7305a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#a52e7e910e26cb4e1a3e6eb387e7305a5">AK_reference_check_if_update_needed</a> (struct list_node *lista, int action)</td></tr>
<tr class="memdesc:a52e7e910e26cb4e1a3e6eb387e7305a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funvction that quickly checks if there are any referential constraints that should be applied on a given list of changes.  <a href="#a52e7e910e26cb4e1a3e6eb387e7305a5">More...</a><br /></td></tr>
<tr class="separator:a52e7e910e26cb4e1a3e6eb387e7305a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8591a73d9dab9148274329a1683f909"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#aa8591a73d9dab9148274329a1683f909">AK_reference_check_restricion</a> (struct list_node *lista, int action)</td></tr>
<tr class="memdesc:aa8591a73d9dab9148274329a1683f909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function checks for REF_TYPE_RESTRICT references appliable to the operation of updating or deleting a row in a table.  <a href="#aa8591a73d9dab9148274329a1683f909">More...</a><br /></td></tr>
<tr class="separator:aa8591a73d9dab9148274329a1683f909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64028d9ef8bc674d737aa12a8065f49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#ac64028d9ef8bc674d737aa12a8065f49">AK_reference_update</a> (struct list_node *lista, int action)</td></tr>
<tr class="memdesc:ac64028d9ef8bc674d737aa12a8065f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function updates child table entries according to ongoing update of parent table entries.  <a href="#ac64028d9ef8bc674d737aa12a8065f49">More...</a><br /></td></tr>
<tr class="separator:ac64028d9ef8bc674d737aa12a8065f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015b40704f67d85d153eeda5e6b82088"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#a015b40704f67d85d153eeda5e6b82088">AK_reference_check_entry</a> (struct list_node *lista)</td></tr>
<tr class="memdesc:a015b40704f67d85d153eeda5e6b82088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function checks new entry for referential integrity.  <a href="#a015b40704f67d85d153eeda5e6b82088">More...</a><br /></td></tr>
<tr class="separator:a015b40704f67d85d153eeda5e6b82088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c889a460fe2392c4b81857c03aedf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#a93c889a460fe2392c4b81857c03aedf2">AK_reference_test</a> ()</td></tr>
<tr class="memdesc:a93c889a460fe2392c4b81857c03aedf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for testing referential integrity.  <a href="#a93c889a460fe2392c4b81857c03aedf2">More...</a><br /></td></tr>
<tr class="separator:a93c889a460fe2392c4b81857c03aedf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f99778d1325dba20d27bfee2fe106c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#ad2f99778d1325dba20d27bfee2fe106c">Ak_Insert_New_Element</a> (int newtype, void *data, char *table, char *attribute_name, struct list_node *ElementBefore)</td></tr>
<tr class="memdesc:ad2f99778d1325dba20d27bfee2fe106c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function inserts new element after some element, to insert on first place give list as before element. It calls function Ak_Insert_New_Element_For_Update.  <a href="#ad2f99778d1325dba20d27bfee2fe106c">More...</a><br /></td></tr>
<tr class="separator:ad2f99778d1325dba20d27bfee2fe106c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f0975e1d6d62009b5c9190e9e4be28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#a83f0975e1d6d62009b5c9190e9e4be28">Ak_insert_row</a> (struct list_node *row_root)</td></tr>
<tr class="memdesc:a83f0975e1d6d62009b5c9190e9e4be28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function inserts a one row into table. Firstly it is checked whether inserted row would violite reference integrity. Then it is checked in which table should row be inserted. If there is no AK_free space for new table, new extent is allocated. New block is allocated on given address. Row is inserted in this block and dirty flag is set to BLOCK_DIRTY.  <a href="#a83f0975e1d6d62009b5c9190e9e4be28">More...</a><br /></td></tr>
<tr class="separator:a83f0975e1d6d62009b5c9190e9e4be28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48193253bfd1b2a279a5772303acba58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#a48193253bfd1b2a279a5772303acba58">AK_selection</a> (char *srcTable, char *dstTable, struct list_node *expr)</td></tr>
<tr class="memdesc:a48193253bfd1b2a279a5772303acba58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which implements selection.  <a href="#a48193253bfd1b2a279a5772303acba58">More...</a><br /></td></tr>
<tr class="separator:a48193253bfd1b2a279a5772303acba58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e954029e28dcf3149c6d9a76b960ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#ad2e954029e28dcf3149c6d9a76b960ab">Ak_Insert_New_Element_For_Update</a> (int newtype, void *data, char *table, char *attribute_name, struct list_node *ElementBefore, int newconstraint)</td></tr>
<tr class="memdesc:ad2e954029e28dcf3149c6d9a76b960ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function inserts new element after some element, to insert on first place give list as before element. New element is allocated. Type, data, attribute name and constraint of new elemets are set according to function arguments. Pointers are changed so that before element points to new element.  <a href="#ad2e954029e28dcf3149c6d9a76b960ab">More...</a><br /></td></tr>
<tr class="separator:ad2e954029e28dcf3149c6d9a76b960ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7b8d65fef8057c0b47502606a34994"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#afa7b8d65fef8057c0b47502606a34994">Ak_delete_row</a> (struct list_node *row_root)</td></tr>
<tr class="memdesc:afa7b8d65fef8057c0b47502606a34994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function deletes rows.  <a href="#afa7b8d65fef8057c0b47502606a34994">More...</a><br /></td></tr>
<tr class="separator:afa7b8d65fef8057c0b47502606a34994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978a5fc0afeea6ec045977d886647ae3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#a978a5fc0afeea6ec045977d886647ae3">Ak_update_row</a> (struct list_node *row_root)</td></tr>
<tr class="memdesc:a978a5fc0afeea6ec045977d886647ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function updates rows of some table.  <a href="#a978a5fc0afeea6ec045977d886647ae3">More...</a><br /></td></tr>
<tr class="separator:a978a5fc0afeea6ec045977d886647ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6dbc1d4356e635929f3f7e30de2ff3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reference_8h.html#ac6dbc1d4356e635929f3f7e30de2ff3b">AK_initialize_new_segment</a> (char *name, int type, <a class="el" href="structAK__header.html">AK_header</a> *header)</td></tr>
<tr class="memdesc:ac6dbc1d4356e635929f3f7e30de2ff3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function initializes new segment and writes its start and finish address in system catalog table. For creting new table, index, temporary table, etc. call this function.  <a href="#ac6dbc1d4356e635929f3f7e30de2ff3b">More...</a><br /></td></tr>
<tr class="separator:ac6dbc1d4356e635929f3f7e30de2ff3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides data structures for referential integrity </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ab683b166173b43a5f4720875815b4ef5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REF_TYPE_NO_ACTION&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant declaring no action reference type. </p>
<p>Constant declaring cascade reference type. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5642d4715910a224460ee3ad66e866e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_add_reference </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>childTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>childAttNames</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>parentTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>parentAttNames</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>constraintName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function adds a reference for a group of attributes over a given table to a group of attributes over another table with a given constraint name.. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Frankovic </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>of the child table </td></tr>
    <tr><td class="paramname">array</td><td>of child table attribute names (foreign key attributes) </td></tr>
    <tr><td class="paramname">name</td><td>of the parent table </td></tr>
    <tr><td class="paramname">array</td><td>of parent table attribute names (primary key attributes) </td></tr>
    <tr><td class="paramname">number</td><td>of attributes in foreign key </td></tr>
    <tr><td class="paramname">name</td><td>of the constraint </td></tr>
    <tr><td class="paramname">type</td><td>of the constraint, constants defined in '<a class="el" href="reference_8h.html">reference.h</a>' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="afa7b8d65fef8057c0b47502606a34994"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ak_delete_row </td>
          <td>(</td>
          <td class="paramtype">struct list_node *&#160;</td>
          <td class="paramname"><em>row_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function deletes rows. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, Dejan Frankovic (added referential integrity) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_root</td><td>elements of one row  EXIT_SUCCESS if success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a649ec65739751d5504693e55184a98a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAK__ref__item.html">AK_ref_item</a> AK_get_reference </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>constraintName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function reads a reference entry from system table. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Frankovic </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>of the table with reference (with foreign key) </td></tr>
    <tr><td class="paramname">name</td><td>of the reference constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structAK__ref__item.html" title="Structure that represents reference item. It contains of table, attributes, parent table and it&#39;s att...">AK_ref_item</a> object with all neccessary information about the reference </dd></dl>

</div>
</div>
<a class="anchor" id="ac6dbc1d4356e635929f3f7e30de2ff3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_initialize_new_segment </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function initializes new segment and writes its start and finish address in system catalog table. For creting new table, index, temporary table, etc. call this function. </p>
<dl class="section author"><dt>Author</dt><dd>Tomislav Fotak, updated by Matija Šestak (function now uses caching) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>segment name </td></tr>
    <tr><td class="paramname">type</td><td>segment type </td></tr>
    <tr><td class="paramname">header</td><td>pointer to header that should be written to the new extent (all blocks) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>start address of new segment </dd></dl>

</div>
</div>
<a class="anchor" id="ad2f99778d1325dba20d27bfee2fe106c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_Insert_New_Element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct list_node *&#160;</td>
          <td class="paramname"><em>ElementBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function inserts new element after some element, to insert on first place give list as before element. It calls function Ak_Insert_New_Element_For_Update. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, changed by Dino Laktašić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newtype</td><td>type of the data </td></tr>
    <tr><td class="paramname">data</td><td>the data </td></tr>
    <tr><td class="paramname">table</td><td>table name </td></tr>
    <tr><td class="paramname">attribute_name</td><td>attribute name </td></tr>
    <tr><td class="paramname">element</td><td>element after we which insert the new element </td></tr>
    <tr><td class="paramname">constraint</td><td>is NEW_VALUE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
<a class="anchor" id="ad2e954029e28dcf3149c6d9a76b960ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_Insert_New_Element_For_Update </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct list_node *&#160;</td>
          <td class="paramname"><em>ElementBefore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newconstraint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function inserts new element after some element, to insert on first place give list as before element. New element is allocated. Type, data, attribute name and constraint of new elemets are set according to function arguments. Pointers are changed so that before element points to new element. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newtype</td><td>type of the data </td></tr>
    <tr><td class="paramname">data</td><td>the data </td></tr>
    <tr><td class="paramname">table</td><td>table name </td></tr>
    <tr><td class="paramname">attribute_name</td><td>attribute name </td></tr>
    <tr><td class="paramname">element</td><td>element after we which insert the new element </td></tr>
    <tr><td class="paramname">constraint</td><td>NEW_VALUE if data is new value, SEARCH_CONSTRAINT if data is constraint to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
<a class="anchor" id="a83f0975e1d6d62009b5c9190e9e4be28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ak_insert_row </td>
          <td>(</td>
          <td class="paramtype">struct list_node *&#160;</td>
          <td class="paramname"><em>row_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function inserts a one row into table. Firstly it is checked whether inserted row would violite reference integrity. Then it is checked in which table should row be inserted. If there is no AK_free space for new table, new extent is allocated. New block is allocated on given address. Row is inserted in this block and dirty flag is set to BLOCK_DIRTY. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, updated by Matija Šestak (function now uses caching), updated by Dejan Frankovic (added reference check), updated by Dino Laktašić (removed variable AK_free, variable table initialized using memset) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_root</td><td>list of elements which contain data of one row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if success else EXIT_ERROR </dd></dl>

</div>
</div>
<a class="anchor" id="a4b180aec5b34a0d6341ca689931521cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_reference_check_attribute </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function checks referential integrity for one attribute. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Frankovic </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>table name </td></tr>
    <tr><td class="paramname">attribute</td><td>name (foreign key attribute) </td></tr>
    <tr><td class="paramname">value</td><td>of the attribute we're checking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT ERROR if check failed, EXIT_SUCCESS if referential integrity is ok </dd></dl>

</div>
</div>
<a class="anchor" id="a015b40704f67d85d153eeda5e6b82088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_reference_check_entry </td>
          <td>(</td>
          <td class="paramtype">struct list_node *&#160;</td>
          <td class="paramname"><em>lista</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function checks new entry for referential integrity. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Franković </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>of elements for insert row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if referential integrity is ok, EXIT_ERROR if it is compromised </dd></dl>

</div>
</div>
<a class="anchor" id="a52e7e910e26cb4e1a3e6eb387e7305a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_reference_check_if_update_needed </td>
          <td>(</td>
          <td class="paramtype">struct list_node *&#160;</td>
          <td class="paramname"><em>lista</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funvction that quickly checks if there are any referential constraints that should be applied on a given list of changes. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Frankovic </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>of elements for update </td></tr>
    <tr><td class="paramname">is</td><td>action UPDATE or DELETE ? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if update is needed, EXIT_ERROR if not </dd></dl>

</div>
</div>
<a class="anchor" id="aa8591a73d9dab9148274329a1683f909"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_reference_check_restricion </td>
          <td>(</td>
          <td class="paramtype">struct list_node *&#160;</td>
          <td class="paramname"><em>lista</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function checks for REF_TYPE_RESTRICT references appliable to the operation of updating or deleting a row in a table. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Franković </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>of elements for update </td></tr>
    <tr><td class="paramname">is</td><td>action UPDATE or DELETE? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if there is no restriction on this action, EXIT_ERROR if there is </dd></dl>

</div>
</div>
<a class="anchor" id="a93c889a460fe2392c4b81857c03aedf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_reference_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for testing referential integrity. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Franković </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
<a class="anchor" id="ac64028d9ef8bc674d737aa12a8065f49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_reference_update </td>
          <td>(</td>
          <td class="paramtype">struct list_node *&#160;</td>
          <td class="paramname"><em>lista</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function updates child table entries according to ongoing update of parent table entries. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Franković </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>of elements for update </td></tr>
    <tr><td class="paramname">is</td><td>action UPDATE or DELETE ? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="a48193253bfd1b2a279a5772303acba58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_selection </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>srcTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dstTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct list_node *&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which implements selection. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Šestak. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*srcTable</td><td>source table name </td></tr>
    <tr><td class="paramname">*dstTable</td><td>destination table name </td></tr>
    <tr><td class="paramname">*expr</td><td>list with posfix notation of the logical expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="a978a5fc0afeea6ec045977d886647ae3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ak_update_row </td>
          <td>(</td>
          <td class="paramtype">struct list_node *&#160;</td>
          <td class="paramname"><em>row_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function updates rows of some table. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, Dejan Frankovic (added referential integrity) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_root</td><td>elements of one row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if success </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
