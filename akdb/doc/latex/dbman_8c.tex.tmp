\hypertarget{dbman_8c}{}\section{dm/dbman.c File Reference}
\label{dbman_8c}\index{dm/dbman.\+c@{dm/dbman.\+c}}
{\ttfamily \#include \char`\"{}dbman.\+h\char`\"{}}\\*
Include dependency graph for dbman.\+c\+:
% FIG 0
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{dbman_8c_a7cacca7e9aebff2aee36f85632e5c35e}{A\+K\+\_\+init\+\_\+db\+\_\+file} (int size)
\begin{DoxyCompactList}\small\item\em Function that initializes a new database file named D\+B\+\_\+\+F\+I\+LE. It opens database file. New block is allocated. In this block type of header is set to F\+R\+E\+E\+\_\+\+I\+NT, attribute names are set to F\+R\+E\+E\+\_\+\+C\+H\+AR, integrities are set to F\+R\+E\+E\+\_\+\+I\+NT, constraint names are set to F\+R\+E\+E\+\_\+\+C\+H\+AR, constraint names and codes are set to F\+R\+E\+E\+\_\+\+C\+H\+AR. Type, address and size of tuples are set to F\+R\+E\+E\+\_\+\+I\+NT. Data in block is set to F\+R\+E\+E\+\_\+\+C\+H\+AR. Type of block is B\+L\+O\+C\+K\+\_\+\+T\+Y\+P\+E\+\_\+\+F\+R\+EE, it is not chained and id of last tuple is 0. \end{DoxyCompactList}\item 
int $\ast$ \hyperlink{dbman_8c_a377b7d3e346a2cbe608d468f4274cda8}{A\+K\+\_\+get\+\_\+allocation\+\_\+set} (int $\ast$bitsetbs, int from\+Where, int gaplength, int num, \hyperlink{dbman_8h_af6d80074e26af6570de6d650c1d90851}{A\+K\+\_\+allocation\+\_\+set\+\_\+mode} mode, int target)
\begin{DoxyCompactList}\small\item\em Function prepare demanded sets from allocation table. \end{DoxyCompactList}\item 
void \hyperlink{dbman_8c_acf09d102942a1534d53d89489591af1b}{A\+K\+\_\+allocationtable\+\_\+dump} (int zz)
\begin{DoxyCompactList}\small\item\em Function dumpes allocation table. \end{DoxyCompactList}\item 
void \hyperlink{dbman_8c_a3956a7198427c0911c2775d382842b98}{A\+K\+\_\+blocktable\+\_\+dump} (int zz)
\begin{DoxyCompactList}\small\item\em Function dumpes allocation table. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_aef4ddae5253862ad465b91b1e940a71f}{A\+K\+\_\+blocktable\+\_\+flush} ()
\begin{DoxyCompactList}\small\item\em Function flushes bitmask table to disk. \end{DoxyCompactList}\item 
void \hyperlink{dbman_8c_ab4a5fe4ed50be350e3c9d9d20a57afbe}{A\+K\+\_\+allocate\+\_\+block\+\_\+activity\+\_\+modes} ()
\begin{DoxyCompactList}\small\item\em Allocation of array which will contain information about which blocks are being accessed. Creates an array. Each element of this array will correspond to one initialized block. For more info, see explanation in \hyperlink{dbman_8h}{dbman.\+h}. \end{DoxyCompactList}\item 
void \hyperlink{dbman_8c_a41ad69e55d09ab4aa2bec6dd34805367}{A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test} ()
\begin{DoxyCompactList}\small\item\em This function tests thread safe reading and writing to blocks. There is N writing and N reading threads, which are going through iterations. Each reading thread should read the data (character) that was set by last writing thread. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{dbman_8c_a5499694bd97b104560d14ef70abe2c73}{A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing} (void $\ast$address)
\begin{DoxyCompactList}\small\item\em This function is only for testing. It has to be there, because pthread\+\_\+create only accepts void$\ast$ function\+\_\+name (void $\ast$) function format. So A\+K\+\_\+read\+\_\+block is no-\/go for pthread\+\_\+create. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{dbman_8c_a0558e034eeed865a1c855de5cfad20ef}{A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing} (void $\ast$block)
\begin{DoxyCompactList}\small\item\em This function is only for testing. It has to be there, because pthread\+\_\+create only accepts void$\ast$ function\+\_\+name (void $\ast$) function format. So A\+K\+\_\+write\+\_\+block is no-\/go for pthread\+\_\+create. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_adcfd5252c0eed066034b558df30cc790}{A\+K\+\_\+blocktable\+\_\+get} ()
\begin{DoxyCompactList}\small\item\em Function gets allocation table from disk. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_adbc6978517271fbd48a004cb039ac6c1}{fsize} (F\+I\+LE $\ast$fp)
\begin{DoxyCompactList}\small\item\em Helper function to determine file size. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_aee0b4429858370953a410c6fb5b9ec92}{A\+K\+\_\+init\+\_\+allocation\+\_\+table} ()
\begin{DoxyCompactList}\small\item\em Function that initializes allocation table, write it to disk and cache in memory. \end{DoxyCompactList}\item 
\hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$ \hyperlink{dbman_8c_a402f984ce7298e193a2a9c5dc5d6b901}{A\+K\+\_\+init\+\_\+block} ()
\begin{DoxyCompactList}\small\item\em Function that initializes new block. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_a3fcca519b1dbe309c683d64b0e955dca}{A\+K\+\_\+print\+\_\+block} (\hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$block, int num, char $\ast$gg, F\+I\+LE $\ast$fpp)
\begin{DoxyCompactList}\small\item\em Function that dumps block. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_ac48b8ab357cefa4ffcc54c348571c1fe}{A\+K\+\_\+allocate\+\_\+blocks} (F\+I\+LE $\ast$\hyperlink{dbman_8h_a89a7f6028a19c3dc081cc5f16eb53891}{db}, \hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$block, int From\+Where, int How\+Many)
\begin{DoxyCompactList}\small\item\em Function that allocates new blocks by placing them to appropriate place and then update last initialized index. \end{DoxyCompactList}\item 
\hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$ \hyperlink{dbman_8c_a2c880db7cf4f8332ae7e93c6b71cc911}{A\+K\+\_\+read\+\_\+block} (int address)
\begin{DoxyCompactList}\small\item\em Function that reads a block at a given address (block number less than db\+\_\+file\+\_\+size). New block is allocated. Database file is opened. Position is set to provided address block. At the end function reads file from that position. Completely thread-\/safe. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_a222ea31aa276d52e464137a3b144f78a}{A\+K\+\_\+write\+\_\+block} (\hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$block)
\begin{DoxyCompactList}\small\item\em Function writes a block to DB file. Database file is opened. Position is set to provided address block. Block is written to provided address. Completely thread-\/safe. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_ad4d4a6ea2344a3003ea50930cc0e77b8}{A\+K\+\_\+copy\+\_\+header} (\hyperlink{structAK__header}{A\+K\+\_\+header} $\ast$header, int $\ast$blocknum, int num)
\begin{DoxyCompactList}\small\item\em Function copy header to blocks. Completely thread-\/safe. \end{DoxyCompactList}\item 
int $\ast$ \hyperlink{dbman_8c_a9525b11c47b5825abb4956add526623c}{A\+K\+\_\+get\+\_\+extent} (int start\+\_\+address, int desired\+\_\+size, \hyperlink{dbman_8h_af6d80074e26af6570de6d650c1d90851}{A\+K\+\_\+allocation\+\_\+set\+\_\+mode} $\ast$mode, int border, int target, \hyperlink{structAK__header}{A\+K\+\_\+header} $\ast$header, int gl)
\begin{DoxyCompactList}\small\item\em Function alocates new extent of blocks. Number of blocks is not ordered as well as a way of search for them. \end{DoxyCompactList}\item 
int $\ast$ \hyperlink{dbman_8c_a9411aae916046fdd8e53ed1760a58b6d}{A\+K\+\_\+increase\+\_\+extent} (int start\+\_\+address, int add\+\_\+size, \hyperlink{dbman_8h_af6d80074e26af6570de6d650c1d90851}{A\+K\+\_\+allocation\+\_\+set\+\_\+mode} $\ast$mode, int border, int target, \hyperlink{structAK__header}{A\+K\+\_\+header} $\ast$header, int gl)
\begin{DoxyCompactList}\small\item\em Function alocates new blocks for increasing extent size. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_a1ff7d6ea92a45cda91ff2063043900a1}{A\+K\+\_\+new\+\_\+extent} (int start\+\_\+address, int old\+\_\+size, int extent\+\_\+type, \hyperlink{structAK__header}{A\+K\+\_\+header} $\ast$header)
\begin{DoxyCompactList}\small\item\em Function alocates new extent of blocks. If argument \char`\"{}old\+\_\+size\char`\"{} is 0 than size of extent is I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE. Otherwise, resize factor is set according to type of extent. If writing of block is successful, number of blocks is incremented. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_a79e7998e69e2910528f7ef258469b2be}{A\+K\+\_\+new\+\_\+segment} (char $\ast$name, int type, \hyperlink{structAK__header}{A\+K\+\_\+header} $\ast$header)
\begin{DoxyCompactList}\small\item\em Function that allocates new segment of extents. In this phase of implementation, only extents containing I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE blocks can be allocated. If extent is successfully allocated, number of allocated extents is incremented and function goes to next block after allocated extent. Otherwise, function moves to I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE blocks. In that way function gets either first block of new extent or some block in that extent which will not be A\+K\+\_\+free. \end{DoxyCompactList}\item 
\hyperlink{structAK__header}{A\+K\+\_\+header} $\ast$ \hyperlink{dbman_8c_adbd8d4f27d7e825392badfcfc4baf968}{A\+K\+\_\+create\+\_\+header} (char $\ast$name, int type, int integrity, char $\ast$constr\+\_\+name, char $\ast$contr\+\_\+code)
\begin{DoxyCompactList}\small\item\em Function for creating header and initalize integrity, constraint name and constraint code with parameter values of function. \end{DoxyCompactList}\item 
void \hyperlink{dbman_8c_a0f011234546a9f1cc751a0d08036b131}{A\+K\+\_\+insert\+\_\+entry} (\hyperlink{structAK__block}{A\+K\+\_\+block} $\ast$block\+\_\+address, int type, void $\ast$entry\+\_\+data, int i)
\begin{DoxyCompactList}\small\item\em Function for inserting entry in tuple\+\_\+dict and data of a block. Address, type and size of catalog\+\_\+tuple\+\_\+dict are set. Free space of block is also set. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_ac48430852cddc2cc7b79dd2775212b10}{A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog} (int relation, int attribute, int index, int view, int sequence, int function, int function\+\_\+arguments, int trigger, int trigger\+\_\+conditions, int \hyperlink{dbman_8h_a89a7f6028a19c3dc081cc5f16eb53891}{db}, int db\+\_\+obj, int user, int group, int user\+\_\+group, int user\+\_\+right, int group\+\_\+right, int constraint, int constraint\+Null, int constraint\+Check, int constraint\+Unique, int reference)
\begin{DoxyCompactList}\small\item\em Function initialises the sytem table catalog and writes the result in first (0) block in db\+\_\+file. Catalog block, catalog header name, catalog header address are allocated. Address, type, chained\+\_\+with and A\+K\+\_\+free\+\_\+space attributes are initialized. Names of various database elements are written in block. \end{DoxyCompactList}\item 
void \hyperlink{dbman_8c_a3157bc3da79c19192a915acc1235bad0}{A\+K\+\_\+memset\+\_\+int} (void $\ast$block, int value, size\+\_\+t num)
\begin{DoxyCompactList}\small\item\em Function that sets the first num ints of a block of memory to the specified value. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_af4c050534ddf6dcf1cba09987424ff76}{A\+K\+\_\+register\+\_\+system\+\_\+tables} (int relation, int attribute, int index, int view, int sequence, int function, int function\+\_\+arguments, int trigger, int trigger\+\_\+conditions, int \hyperlink{dbman_8h_a89a7f6028a19c3dc081cc5f16eb53891}{db}, int db\+\_\+obj, int user, int group, int user\+\_\+group, int user\+\_\+right, int group\+\_\+right, int constraint, int constraint\+Null, int constraint\+Check, int constraint\+Unique, int reference)
\begin{DoxyCompactList}\small\item\em Function that registers system tables. Block at the given address is read. Various data from function arguments are written in block about different database elements. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_af99cdc5c8456ad5ff87fb542d030c4d6}{A\+K\+\_\+init\+\_\+system\+\_\+catalog} ()
\begin{DoxyCompactList}\small\item\em Function initializes the system catalog. Headers for system tables are defined. Segments for those system tables are allocated. Above function \hyperlink{dbman_8c_af4c050534ddf6dcf1cba09987424ff76}{A\+K\+\_\+register\+\_\+system\+\_\+tables()} to register system tables. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_a5058a1dd8adfdd5663626492f1d1f257}{A\+K\+\_\+delete\+\_\+block} (int address)
\begin{DoxyCompactList}\small\item\em Function deletes a block by a given block address (resets the header and data). Types, integrities, constraint names, constraint codes are set to \char`\"{}\+A\+K\+\_\+free\char`\"{} values. In tuple dictionary type, address and size are set to F\+R\+E\+E\+\_\+\+I\+NT values. Data of block is set to F\+R\+E\+E\+\_\+\+C\+H\+AR. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_a1c0ef3161f926bef80f12aa4e0905acd}{A\+K\+\_\+delete\+\_\+extent} (int begin, int end)
\begin{DoxyCompactList}\small\item\em Function deletes an extent between begin and end blocks. \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_a0a6e9ee9800548168a235c26fcceba71}{A\+K\+\_\+delete\+\_\+segment} (char $\ast$name, int type)
\item 
int \hyperlink{dbman_8c_a7e7d6a4c56ce0c15b59217a3607db06e}{A\+K\+\_\+init\+\_\+disk\+\_\+manager} ()
\item 
void {\bfseries A\+K\+\_\+allocationbit\+\_\+test} ()\hypertarget{dbman_8c_a195049d1c2185a540f18cf1711e2f448}{}\label{dbman_8c_a195049d1c2185a540f18cf1711e2f448}

\item 
void {\bfseries A\+K\+\_\+allocationtable\+\_\+test} ()\hypertarget{dbman_8c_a35e134c23957bd5971723676e5fb4a2d}{}\label{dbman_8c_a35e134c23957bd5971723676e5fb4a2d}

\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
pthread\+\_\+mutex\+\_\+t {\bfseries file\+Lock\+Mutex} = P\+T\+H\+R\+E\+A\+D\+\_\+\+M\+U\+T\+E\+X\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+ER\hypertarget{dbman_8c_aa74b62e850a091e2305da8dc8ab1e1de}{}\label{dbman_8c_aa74b62e850a091e2305da8dc8ab1e1de}

\item 
char \hyperlink{dbman_8c_a75d8194a70159d3603f73699e7f1ed6f}{test\+\_\+last\+Character\+Written} = \textquotesingle{}\textbackslash{}0\textquotesingle{}\hypertarget{dbman_8c_a75d8194a70159d3603f73699e7f1ed6f}{}\label{dbman_8c_a75d8194a70159d3603f73699e7f1ed6f}

\begin{DoxyCompactList}\small\item\em This variable is used only when T\+E\+S\+T\+\_\+\+M\+O\+DE is O\+N! It is used only for testing functionality of \hyperlink{dbman_8c_a41ad69e55d09ab4aa2bec6dd34805367}{A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test()} function. It will contain first character of last written block. When reading thread reads the block (written by some other thread), it will compare the first character from this block to character containted in this wariables. If they don\textquotesingle{}t match, then the error occured! It is assumed that the same block is being written to and read from (just like A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test function works!) \end{DoxyCompactList}\item 
int \hyperlink{dbman_8c_aef8ef161a5a8600479cc77f15d7b859e}{test\+\_\+thread\+Safe\+Block\+Access\+Succeeded} = 1\hypertarget{dbman_8c_aef8ef161a5a8600479cc77f15d7b859e}{}\label{dbman_8c_aef8ef161a5a8600479cc77f15d7b859e}

\begin{DoxyCompactList}\small\item\em Used in combination with test\+\_\+last\+Character\+Written. Will give the answer to question\+: \char`\"{}\+Has A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test suceeded?\char`\"{} 0 means NO, 1 means Y\+ES. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Defines functions for the disk manager 

\subsection{Function Documentation}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+allocate\+\_\+block\+\_\+activity\+\_\+modes@{A\+K\+\_\+allocate\+\_\+block\+\_\+activity\+\_\+modes}}
\index{A\+K\+\_\+allocate\+\_\+block\+\_\+activity\+\_\+modes@{A\+K\+\_\+allocate\+\_\+block\+\_\+activity\+\_\+modes}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+allocate\+\_\+block\+\_\+activity\+\_\+modes()}{AK_allocate_block_activity_modes()}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+allocate\+\_\+block\+\_\+activity\+\_\+modes (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_ab4a5fe4ed50be350e3c9d9d20a57afbe}{}\label{dbman_8c_ab4a5fe4ed50be350e3c9d9d20a57afbe}


Allocation of array which will contain information about which blocks are being accessed. Creates an array. Each element of this array will correspond to one initialized block. For more info, see explanation in \hyperlink{dbman_8h}{dbman.\+h}. 

\begin{DoxyAuthor}{Author}
Domagoj Šitum 
\end{DoxyAuthor}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+allocate\+\_\+blocks@{A\+K\+\_\+allocate\+\_\+blocks}}
\index{A\+K\+\_\+allocate\+\_\+blocks@{A\+K\+\_\+allocate\+\_\+blocks}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+allocate\+\_\+blocks(\+F\+I\+L\+E $\ast$db, A\+K\+\_\+block $\ast$block, int From\+Where, int How\+Many)}{AK_allocate_blocks(FILE *db, AK_block *block, int FromWhere, int HowMany)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+allocate\+\_\+blocks (
\begin{DoxyParamCaption}
\item[{F\+I\+LE $\ast$}]{db, }
\item[{{\bf A\+K\+\_\+block} $\ast$}]{block, }
\item[{int}]{From\+Where, }
\item[{int}]{How\+Many}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_ac48b8ab357cefa4ffcc54c348571c1fe}{}\label{dbman_8c_ac48b8ab357cefa4ffcc54c348571c1fe}


Function that allocates new blocks by placing them to appropriate place and then update last initialized index. 

\begin{DoxyAuthor}{Author}
Markus Schatten , rearranged by dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if the file has been written to disk, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+allocationtable\+\_\+dump@{A\+K\+\_\+allocationtable\+\_\+dump}}
\index{A\+K\+\_\+allocationtable\+\_\+dump@{A\+K\+\_\+allocationtable\+\_\+dump}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+allocationtable\+\_\+dump(int zz)}{AK_allocationtable_dump(int zz)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+allocationtable\+\_\+dump (
\begin{DoxyParamCaption}
\item[{int}]{zz}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_acf09d102942a1534d53d89489591af1b}{}\label{dbman_8c_acf09d102942a1534d53d89489591af1b}


Function dumpes allocation table. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
nothing 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+blocktable\+\_\+dump@{A\+K\+\_\+blocktable\+\_\+dump}}
\index{A\+K\+\_\+blocktable\+\_\+dump@{A\+K\+\_\+blocktable\+\_\+dump}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+blocktable\+\_\+dump(int zz)}{AK_blocktable_dump(int zz)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+blocktable\+\_\+dump (
\begin{DoxyParamCaption}
\item[{int}]{zz}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a3956a7198427c0911c2775d382842b98}{}\label{dbman_8c_a3956a7198427c0911c2775d382842b98}


Function dumpes allocation table. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
nothing 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+blocktable\+\_\+flush@{A\+K\+\_\+blocktable\+\_\+flush}}
\index{A\+K\+\_\+blocktable\+\_\+flush@{A\+K\+\_\+blocktable\+\_\+flush}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+blocktable\+\_\+flush()}{AK_blocktable_flush()}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+blocktable\+\_\+flush (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_aef4ddae5253862ad465b91b1e940a71f}{}\label{dbman_8c_aef4ddae5253862ad465b91b1e940a71f}


Function flushes bitmask table to disk. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if the file has been written to disk, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+blocktable\+\_\+get@{A\+K\+\_\+blocktable\+\_\+get}}
\index{A\+K\+\_\+blocktable\+\_\+get@{A\+K\+\_\+blocktable\+\_\+get}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+blocktable\+\_\+get()}{AK_blocktable_get()}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+blocktable\+\_\+get (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_adcfd5252c0eed066034b558df30cc790}{}\label{dbman_8c_adcfd5252c0eed066034b558df30cc790}


Function gets allocation table from disk. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if the file has been taken from disk, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+copy\+\_\+header@{A\+K\+\_\+copy\+\_\+header}}
\index{A\+K\+\_\+copy\+\_\+header@{A\+K\+\_\+copy\+\_\+header}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+copy\+\_\+header(\+A\+K\+\_\+header $\ast$header, int $\ast$blocknum, int num)}{AK_copy_header(AK_header *header, int *blocknum, int num)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+copy\+\_\+header (
\begin{DoxyParamCaption}
\item[{{\bf A\+K\+\_\+header} $\ast$}]{header, }
\item[{int $\ast$}]{blocknum, }
\item[{int}]{num}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_ad4d4a6ea2344a3003ea50930cc0e77b8}{}\label{dbman_8c_ad4d4a6ea2344a3003ea50930cc0e77b8}


Function copy header to blocks. Completely thread-\/safe. 

\begin{DoxyAuthor}{Author}
Nikola Bakoš, updated by Dino Laktašiæ (fixed header B\+UG), refurbished by dv 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em header} & pointer to header provided for copy \\
\hline
{\em blocknum} & pointer to addresses of blocks that header needs to be copied \\
\hline
{\em num} & number of blocks waiting for its header \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of performed header copy 
\end{DoxyReturn}
var to check the number of written blocks

if write of block succeded increase var num\+\_\+blocks, else nothing \index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+create\+\_\+header@{A\+K\+\_\+create\+\_\+header}}
\index{A\+K\+\_\+create\+\_\+header@{A\+K\+\_\+create\+\_\+header}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+create\+\_\+header(char $\ast$name, int type, int integrity, char $\ast$constr\+\_\+name, char $\ast$contr\+\_\+code)}{AK_create_header(char *name, int type, int integrity, char *constr_name, char *contr_code)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf A\+K\+\_\+header}$\ast$ A\+K\+\_\+create\+\_\+header (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{name, }
\item[{int}]{type, }
\item[{int}]{integrity, }
\item[{char $\ast$}]{constr\+\_\+name, }
\item[{char $\ast$}]{contr\+\_\+code}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_adbd8d4f27d7e825392badfcfc4baf968}{}\label{dbman_8c_adbd8d4f27d7e825392badfcfc4baf968}


Function for creating header and initalize integrity, constraint name and constraint code with parameter values of function. 

\begin{DoxyAuthor}{Author}
Matija Novak 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em name} & name of the atribute \\
\hline
{\em type} & type of the atribute \\
\hline
{\em integrity} & standard integrity costraint \\
\hline
{\em constr\+\_\+name} & extra integrity constraint name \\
\hline
{\em contr\+\_\+code} & extra integrity costraint code \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structAK__header}{A\+K\+\_\+header} 
\end{DoxyReturn}
initialize catalog\+\_\+header-\/$>$integrity and catalog\+\_\+header-\/$>$constr\+\_\+name\mbox{[}\mbox{]}\mbox{[}\mbox{]} and catalog\+\_\+header-\/$>$constr\+\_\+code\mbox{[}\mbox{]}\mbox{[}\mbox{]} with data given as functions parameters \index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+delete\+\_\+block@{A\+K\+\_\+delete\+\_\+block}}
\index{A\+K\+\_\+delete\+\_\+block@{A\+K\+\_\+delete\+\_\+block}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+delete\+\_\+block(int address)}{AK_delete_block(int address)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+delete\+\_\+block (
\begin{DoxyParamCaption}
\item[{int}]{address}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a5058a1dd8adfdd5663626492f1d1f257}{}\label{dbman_8c_a5058a1dd8adfdd5663626492f1d1f257}


Function deletes a block by a given block address (resets the header and data). Types, integrities, constraint names, constraint codes are set to \char`\"{}\+A\+K\+\_\+free\char`\"{} values. In tuple dictionary type, address and size are set to F\+R\+E\+E\+\_\+\+I\+NT values. Data of block is set to F\+R\+E\+E\+\_\+\+C\+H\+AR. 

\begin{DoxyAuthor}{Author}
Markus Schatten 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em address} & address of the block to be deleted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if deletion successful, else E\+X\+I\+T\+\_\+\+E\+R\+R\+OR 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+delete\+\_\+extent@{A\+K\+\_\+delete\+\_\+extent}}
\index{A\+K\+\_\+delete\+\_\+extent@{A\+K\+\_\+delete\+\_\+extent}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+delete\+\_\+extent(int begin, int end)}{AK_delete_extent(int begin, int end)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+delete\+\_\+extent (
\begin{DoxyParamCaption}
\item[{int}]{begin, }
\item[{int}]{end}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a1c0ef3161f926bef80f12aa4e0905acd}{}\label{dbman_8c_a1c0ef3161f926bef80f12aa4e0905acd}


Function deletes an extent between begin and end blocks. 

\begin{DoxyAuthor}{Author}
Dejan Samboliæ 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em begin} & address of extent\textquotesingle{}s first block \\
\hline
{\em end} & address of extent\textquotesingle{}s last block \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if extent has been successfully deleted, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+delete\+\_\+segment@{A\+K\+\_\+delete\+\_\+segment}}
\index{A\+K\+\_\+delete\+\_\+segment@{A\+K\+\_\+delete\+\_\+segment}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+delete\+\_\+segment(char $\ast$name, int type)}{AK_delete_segment(char *name, int type)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+delete\+\_\+segment (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{name, }
\item[{int}]{type}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a0a6e9ee9800548168a235c26fcceba71}{}\label{dbman_8c_a0a6e9ee9800548168a235c26fcceba71}
\begin{DoxyAuthor}{Author}
Mislav Èakariæ 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em name} & name of the segment \\
\hline
{\em type} & type of the segment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if extent has been successfully deleted, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+get\+\_\+allocation\+\_\+set@{A\+K\+\_\+get\+\_\+allocation\+\_\+set}}
\index{A\+K\+\_\+get\+\_\+allocation\+\_\+set@{A\+K\+\_\+get\+\_\+allocation\+\_\+set}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+get\+\_\+allocation\+\_\+set(int $\ast$bitsetbs, int from\+Where, int gaplength, int num, A\+K\+\_\+allocation\+\_\+set\+\_\+mode mode, int target)}{AK_get_allocation_set(int *bitsetbs, int fromWhere, int gaplength, int num, AK_allocation_set_mode mode, int target)}}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ A\+K\+\_\+get\+\_\+allocation\+\_\+set (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{bitsetbs, }
\item[{int}]{from\+Where, }
\item[{int}]{gaplength, }
\item[{int}]{num, }
\item[{{\bf A\+K\+\_\+allocation\+\_\+set\+\_\+mode}}]{mode, }
\item[{int}]{target}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a377b7d3e346a2cbe608d468f4274cda8}{}\label{dbman_8c_a377b7d3e346a2cbe608d468f4274cda8}


Function prepare demanded sets from allocation table. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em bitset} & int pointer, cointainer for bit set \\
\hline
{\em from\+Where} & has meaning just in S\+E\+Q\+U\+E\+N\+CE case. It describes from which address searching have to start. \\
\hline
{\em gaplength} & tells how many used blocks could be tolerated in bitset \\
\hline
{\em num} & Tells how many A\+K\+\_\+free blocks has been needed \\
\hline
{\em mode} & Defines how to obtain set of indexes to A\+K\+\_\+free addresses \\
\hline
{\em target} & has meaning just in case mode=A\+R\+O\+U\+ND\+: set must be as much as possible close to target from both sides \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to integer indexes field with prepared set. If it , for any reason, is not possible set has F\+R\+E\+E\+\_\+\+I\+NT fullfilment. 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+get\+\_\+extent@{A\+K\+\_\+get\+\_\+extent}}
\index{A\+K\+\_\+get\+\_\+extent@{A\+K\+\_\+get\+\_\+extent}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+get\+\_\+extent(int start\+\_\+address, int desired\+\_\+size, A\+K\+\_\+allocation\+\_\+set\+\_\+mode $\ast$mode, int border, int target, A\+K\+\_\+header $\ast$header, int gl)}{AK_get_extent(int start_address, int desired_size, AK_allocation_set_mode *mode, int border, int target, AK_header *header, int gl)}}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ A\+K\+\_\+get\+\_\+extent (
\begin{DoxyParamCaption}
\item[{int}]{start\+\_\+address, }
\item[{int}]{desired\+\_\+size, }
\item[{{\bf A\+K\+\_\+allocation\+\_\+set\+\_\+mode} $\ast$}]{mode, }
\item[{int}]{border, }
\item[{int}]{target, }
\item[{{\bf A\+K\+\_\+header} $\ast$}]{header, }
\item[{int}]{gl}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a9525b11c47b5825abb4956add526623c}{}\label{dbman_8c_a9525b11c47b5825abb4956add526623c}


Function alocates new extent of blocks. Number of blocks is not ordered as well as a way of search for them. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em start\+\_\+address} & address (block number) to start searching for sufficient space \\
\hline
{\em desired\+\_\+size} & number of desired blocks \\
\hline
{\em A\+K\+\_\+allocation\+\_\+set\+\_\+mode} & a way of trying to fing A\+K\+\_\+free space. Can be one of\+: allocation\+S\+E\+Q\+U\+E\+N\+CE, allocation\+U\+P\+P\+ER, allocation\+L\+O\+W\+ER, allocation\+A\+R\+O\+U\+ND \\
\hline
{\em border} & number of allocated blocks gap \\
\hline
{\em target} & block address around which other blocks have to be searched \\
\hline
{\em header} & pointer to header that should be written to the new extent (all blocks) \\
\hline
{\em int} & gl gap size \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to set of alocated block addresses 
\end{DoxyReturn}
vars for loop \mbox{[}for\mbox{]}

if some blocks are not succesfully allocated, which means that the extend allocation has F\+A\+I\+L\+ED \index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+increase\+\_\+extent@{A\+K\+\_\+increase\+\_\+extent}}
\index{A\+K\+\_\+increase\+\_\+extent@{A\+K\+\_\+increase\+\_\+extent}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+increase\+\_\+extent(int start\+\_\+address, int add\+\_\+size, A\+K\+\_\+allocation\+\_\+set\+\_\+mode $\ast$mode, int border, int target, A\+K\+\_\+header $\ast$header, int gl)}{AK_increase_extent(int start_address, int add_size, AK_allocation_set_mode *mode, int border, int target, AK_header *header, int gl)}}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ A\+K\+\_\+increase\+\_\+extent (
\begin{DoxyParamCaption}
\item[{int}]{start\+\_\+address, }
\item[{int}]{add\+\_\+size, }
\item[{{\bf A\+K\+\_\+allocation\+\_\+set\+\_\+mode} $\ast$}]{mode, }
\item[{int}]{border, }
\item[{int}]{target, }
\item[{{\bf A\+K\+\_\+header} $\ast$}]{header, }
\item[{int}]{gl}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a9411aae916046fdd8e53ed1760a58b6d}{}\label{dbman_8c_a9411aae916046fdd8e53ed1760a58b6d}


Function alocates new blocks for increasing extent size. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em start\+\_\+address} & first address of extent that is subject of increasing \\
\hline
{\em add\+\_\+size} & number how many new blocks is to be added to existing extent \\
\hline
{\em A\+K\+\_\+allocation\+\_\+set\+\_\+mode} & a way of trying to fing A\+K\+\_\+free space. Can be one of\+: allocation\+S\+E\+Q\+U\+E\+N\+CE, allocation\+U\+P\+P\+ER, allocation\+L\+O\+W\+ER, allocation\+A\+R\+O\+U\+ND \\
\hline
{\em border} & number of allocated blocks gap \\
\hline
{\em target} & block address around which other blocks have to be searched \\
\hline
{\em header} & pointer to header that should be written to the new extent (all blocks) \\
\hline
{\em int} & gl gap size \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to set of alocated block addresses 
\end{DoxyReturn}
vars for loop \mbox{[}for\mbox{]} \index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+init\+\_\+allocation\+\_\+table@{A\+K\+\_\+init\+\_\+allocation\+\_\+table}}
\index{A\+K\+\_\+init\+\_\+allocation\+\_\+table@{A\+K\+\_\+init\+\_\+allocation\+\_\+table}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+init\+\_\+allocation\+\_\+table()}{AK_init_allocation_table()}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+init\+\_\+allocation\+\_\+table (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_aee0b4429858370953a410c6fb5b9ec92}{}\label{dbman_8c_aee0b4429858370953a410c6fb5b9ec92}


Function that initializes allocation table, write it to disk and cache in memory. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if the file has been written to disk, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+init\+\_\+block@{A\+K\+\_\+init\+\_\+block}}
\index{A\+K\+\_\+init\+\_\+block@{A\+K\+\_\+init\+\_\+block}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+init\+\_\+block()}{AK_init_block()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf A\+K\+\_\+block}$\ast$ A\+K\+\_\+init\+\_\+block (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a402f984ce7298e193a2a9c5dc5d6b901}{}\label{dbman_8c_a402f984ce7298e193a2a9c5dc5d6b901}


Function that initializes new block. 

\begin{DoxyAuthor}{Author}
Markus Schatten , rearranged by dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
pointer to block allocated in memory 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+init\+\_\+db\+\_\+file@{A\+K\+\_\+init\+\_\+db\+\_\+file}}
\index{A\+K\+\_\+init\+\_\+db\+\_\+file@{A\+K\+\_\+init\+\_\+db\+\_\+file}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+init\+\_\+db\+\_\+file(int size)}{AK_init_db_file(int size)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+init\+\_\+db\+\_\+file (
\begin{DoxyParamCaption}
\item[{int}]{size}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a7cacca7e9aebff2aee36f85632e5c35e}{}\label{dbman_8c_a7cacca7e9aebff2aee36f85632e5c35e}


Function that initializes a new database file named D\+B\+\_\+\+F\+I\+LE. It opens database file. New block is allocated. In this block type of header is set to F\+R\+E\+E\+\_\+\+I\+NT, attribute names are set to F\+R\+E\+E\+\_\+\+C\+H\+AR, integrities are set to F\+R\+E\+E\+\_\+\+I\+NT, constraint names are set to F\+R\+E\+E\+\_\+\+C\+H\+AR, constraint names and codes are set to F\+R\+E\+E\+\_\+\+C\+H\+AR. Type, address and size of tuples are set to F\+R\+E\+E\+\_\+\+I\+NT. Data in block is set to F\+R\+E\+E\+\_\+\+C\+H\+AR. Type of block is B\+L\+O\+C\+K\+\_\+\+T\+Y\+P\+E\+\_\+\+F\+R\+EE, it is not chained and id of last tuple is 0. 

\begin{DoxyAuthor}{Author}
Markus Schatten 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em size} & size of new file in in blocks \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if the file has been written to disk, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+init\+\_\+disk\+\_\+manager@{A\+K\+\_\+init\+\_\+disk\+\_\+manager}}
\index{A\+K\+\_\+init\+\_\+disk\+\_\+manager@{A\+K\+\_\+init\+\_\+disk\+\_\+manager}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+init\+\_\+disk\+\_\+manager()}{AK_init_disk_manager()}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+init\+\_\+disk\+\_\+manager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a7e7d6a4c56ce0c15b59217a3607db06e}{}\label{dbman_8c_a7e7d6a4c56ce0c15b59217a3607db06e}
\begin{DoxyAuthor}{Author}
Markus Schatten 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
Function that calls functions \hyperlink{dbman_8c_a7cacca7e9aebff2aee36f85632e5c35e}{A\+K\+\_\+init\+\_\+db\+\_\+file()} and \hyperlink{dbman_8c_af99cdc5c8456ad5ff87fb542d030c4d6}{A\+K\+\_\+init\+\_\+system\+\_\+catalog()} to initialize disk manager. It also calls A\+K\+\_\+allocate\+\_\+array\+\_\+currently\+\_\+accessed\+\_\+blocks() to allocate memory needed for thread-\/safe reading and writing to disk. 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+init\+\_\+system\+\_\+catalog@{A\+K\+\_\+init\+\_\+system\+\_\+catalog}}
\index{A\+K\+\_\+init\+\_\+system\+\_\+catalog@{A\+K\+\_\+init\+\_\+system\+\_\+catalog}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+init\+\_\+system\+\_\+catalog()}{AK_init_system_catalog()}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+init\+\_\+system\+\_\+catalog (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_af99cdc5c8456ad5ff87fb542d030c4d6}{}\label{dbman_8c_af99cdc5c8456ad5ff87fb542d030c4d6}


Function initializes the system catalog. Headers for system tables are defined. Segments for those system tables are allocated. Above function \hyperlink{dbman_8c_af4c050534ddf6dcf1cba09987424ff76}{A\+K\+\_\+register\+\_\+system\+\_\+tables()} to register system tables. 

\begin{DoxyAuthor}{Author}
Miroslav Policki 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if the system catalog has been successfully initialized, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog@{A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog}}
\index{A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog@{A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog(int relation, int attribute, int index, int view, int sequence, int function, int function\+\_\+arguments, int trigger, int trigger\+\_\+conditions, int db, int db\+\_\+obj, int user, int group, int user\+\_\+group, int user\+\_\+right, int group\+\_\+right, int constraint, int constraint\+Null, int constraint\+Check, int constraint\+Unique, int reference)}{AK_init_system_tables_catalog(int relation, int attribute, int index, int view, int sequence, int function, int function_arguments, int trigger, int trigger_conditions, int db, int db_obj, int user, int group, int user_group, int user_right, int group_right, int constraint, int constraintNull, int constraintCheck, int constraintUnique, int reference)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+init\+\_\+system\+\_\+tables\+\_\+catalog (
\begin{DoxyParamCaption}
\item[{int}]{relation, }
\item[{int}]{attribute, }
\item[{int}]{index, }
\item[{int}]{view, }
\item[{int}]{sequence, }
\item[{int}]{function, }
\item[{int}]{function\+\_\+arguments, }
\item[{int}]{trigger, }
\item[{int}]{trigger\+\_\+conditions, }
\item[{int}]{db, }
\item[{int}]{db\+\_\+obj, }
\item[{int}]{user, }
\item[{int}]{group, }
\item[{int}]{user\+\_\+group, }
\item[{int}]{user\+\_\+right, }
\item[{int}]{group\+\_\+right, }
\item[{int}]{constraint, }
\item[{int}]{constraint\+Null, }
\item[{int}]{constraint\+Check, }
\item[{int}]{constraint\+Unique, }
\item[{int}]{reference}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_ac48430852cddc2cc7b79dd2775212b10}{}\label{dbman_8c_ac48430852cddc2cc7b79dd2775212b10}


Function initialises the sytem table catalog and writes the result in first (0) block in db\+\_\+file. Catalog block, catalog header name, catalog header address are allocated. Address, type, chained\+\_\+with and A\+K\+\_\+free\+\_\+space attributes are initialized. Names of various database elements are written in block. 

\begin{DoxyAuthor}{Author}
Matija Novak 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em relation} & address of system table of relation in db\+\_\+file \\
\hline
{\em attribute} & address of system table of attribute in db\+\_\+file \\
\hline
{\em index} & address of system table of index in db\+\_\+file \\
\hline
{\em view} & address of system table of view in db\+\_\+file \\
\hline
{\em sequence} & address of system table of sequence in db\+\_\+file \\
\hline
{\em function} & address of system table of function in db\+\_\+file \\
\hline
{\em function\+\_\+arguments} & address of system table of function\+\_\+arguments in db\+\_\+file \\
\hline
{\em trigger} & address of system table of trigger in db\+\_\+file \\
\hline
{\em trigger\+\_\+conditions} & address of system table of trigger\+\_\+conditions in db\+\_\+file \\
\hline
{\em db} & address of system table of db in db\+\_\+file \\
\hline
{\em db\+\_\+obj} & address of system table of db\+\_\+obj in db\+\_\+file \\
\hline
{\em user} & address of system table of user in db\+\_\+file \\
\hline
{\em group} & address of system table of group in db\+\_\+file \\
\hline
{\em user\+\_\+group} & address of system table of users associated with groups in db\+\_\+file \\
\hline
{\em user\+\_\+right} & address of system table of user right in db\+\_\+file \\
\hline
{\em group\+\_\+right} & address of system table of group right in db\+\_\+file \\
\hline
{\em constraint} & address of system table of constraint in db\+\_\+file \\
\hline
{\em constraint\+Null} & address of system table of constraint\+Null in db\+\_\+file \\
\hline
{\em constraint\+Check} & system table address for check constraint \\
\hline
{\em reference} & address of system table of reference in db\+\_\+file \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if initialization was succesful if not returns E\+X\+I\+T\+\_\+\+E\+R\+R\+OR 
\end{DoxyReturn}
first header attribute of catalog\+\_\+block

second attribute of catalog\+\_\+block

initialize other elements of block (adress, type, chained\+\_\+with, A\+K\+\_\+free\+\_\+space)

using as an address for the first A\+K\+\_\+free space in block-\/$>$data

merge catalog\+\_\+heder with heders created before

insert data and tuple\+\_\+dict in block

call function for writing the block on the first place in the file (ie. first block is on position zero) \index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+insert\+\_\+entry@{A\+K\+\_\+insert\+\_\+entry}}
\index{A\+K\+\_\+insert\+\_\+entry@{A\+K\+\_\+insert\+\_\+entry}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+insert\+\_\+entry(\+A\+K\+\_\+block $\ast$block\+\_\+address, int type, void $\ast$entry\+\_\+data, int i)}{AK_insert_entry(AK_block *block_address, int type, void *entry_data, int i)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+insert\+\_\+entry (
\begin{DoxyParamCaption}
\item[{{\bf A\+K\+\_\+block} $\ast$}]{block\+\_\+address, }
\item[{int}]{type, }
\item[{void $\ast$}]{entry\+\_\+data, }
\item[{int}]{i}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a0f011234546a9f1cc751a0d08036b131}{}\label{dbman_8c_a0f011234546a9f1cc751a0d08036b131}


Function for inserting entry in tuple\+\_\+dict and data of a block. Address, type and size of catalog\+\_\+tuple\+\_\+dict are set. Free space of block is also set. 

\begin{DoxyAuthor}{Author}
Matija Novak 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em block\+\_\+adress} & adress of a block in which we want insert data \\
\hline
{\em type} & type of entry\+\_\+data \\
\hline
{\em entry\+\_\+data} & (char) data which is inserted, can be int but must first be converted to char \\
\hline
{\em i} & (int) adress in tuple\+\_\+dict array (example block\+\_\+address-\/$>$tuple\+\_\+dict\mbox{[}i\mbox{]}) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
No return value because it gets the address of an block like a function parameter and works directly with the orginal block 
\end{DoxyReturn}
using strlen becuse sizeof(entry\+\_\+data) is always 4 copy data into bloc-\/$>$data on start position bloc-\/$>$A\+K\+\_\+free\+\_\+space

address of entry data in block-\/$>$data

calculate next A\+K\+\_\+free space for the next entry data \begin{DoxyVerb}                                                              sizeof(entry_data)+1);///(sizeof(int));
\end{DoxyVerb}
 no need for \char`\"{}+strlen(entry\+\_\+data)\char`\"{} while \char`\"{}+1\char`\"{} is like \char`\"{}new line\char`\"{}

type of entry data

size of entry data

copy tuple\+\_\+dict to block-\/$>$tuple\+\_\+dict\mbox{[}i\mbox{]} must use \& becouse tuple\+\_\+dict\mbox{[}i\mbox{]} is value and catalog\+\_\+tuple\+\_\+dict adress \index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+memset\+\_\+int@{A\+K\+\_\+memset\+\_\+int}}
\index{A\+K\+\_\+memset\+\_\+int@{A\+K\+\_\+memset\+\_\+int}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+memset\+\_\+int(void $\ast$block, int value, size\+\_\+t num)}{AK_memset_int(void *block, int value, size_t num)}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+memset\+\_\+int (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{block, }
\item[{int}]{value, }
\item[{size\+\_\+t}]{num}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a3157bc3da79c19192a915acc1235bad0}{}\label{dbman_8c_a3157bc3da79c19192a915acc1235bad0}


Function that sets the first num ints of a block of memory to the specified value. 

\begin{DoxyAuthor}{Author}
Miroslav Policki 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em block} & pointer to the block of memory to fill \\
\hline
{\em value} & int value to be set \\
\hline
{\em num} & number of ints in the block of memory to be set \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
No return value 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+new\+\_\+extent@{A\+K\+\_\+new\+\_\+extent}}
\index{A\+K\+\_\+new\+\_\+extent@{A\+K\+\_\+new\+\_\+extent}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+new\+\_\+extent(int start\+\_\+address, int old\+\_\+size, int extent\+\_\+type, A\+K\+\_\+header $\ast$header)}{AK_new_extent(int start_address, int old_size, int extent_type, AK_header *header)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+new\+\_\+extent (
\begin{DoxyParamCaption}
\item[{int}]{start\+\_\+address, }
\item[{int}]{old\+\_\+size, }
\item[{int}]{extent\+\_\+type, }
\item[{{\bf A\+K\+\_\+header} $\ast$}]{header}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a1ff7d6ea92a45cda91ff2063043900a1}{}\label{dbman_8c_a1ff7d6ea92a45cda91ff2063043900a1}


Function alocates new extent of blocks. If argument \char`\"{}old\+\_\+size\char`\"{} is 0 than size of extent is I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE. Otherwise, resize factor is set according to type of extent. If writing of block is successful, number of blocks is incremented. 

\begin{DoxyAuthor}{Author}
Nikola Bakoš, updated by Dino Laktašiæ (fixed header B\+UG), refurbished by dv 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em start\+\_\+address} & address (block number) to start searching for sufficient space \\
\hline
{\em old\+\_\+size} & size of previous extent in same segment (in blocks) \\
\hline
{\em extent\+\_\+type} & type of extent (can be one of\+: S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+S\+Y\+S\+T\+E\+M\+\_\+\+T\+A\+B\+LE, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+A\+B\+LE, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+N\+D\+EX, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+R\+A\+N\+S\+A\+C\+T\+I\+ON, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+E\+MP \\
\hline
{\em header} & pointer to header that should be written to the new extent (all blocks) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
address (block number) of new extent if successful, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
var -\/ How much of space is required for extent

vars for loop \mbox{[}for\mbox{]}

if the old\+\_\+size is 0 then the size of new extent is I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE

if some blocks are not succesfully allocated, which means that the extend allocation has F\+A\+I\+L\+ED \index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+new\+\_\+segment@{A\+K\+\_\+new\+\_\+segment}}
\index{A\+K\+\_\+new\+\_\+segment@{A\+K\+\_\+new\+\_\+segment}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+new\+\_\+segment(char $\ast$name, int type, A\+K\+\_\+header $\ast$header)}{AK_new_segment(char *name, int type, AK_header *header)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+new\+\_\+segment (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{name, }
\item[{int}]{type, }
\item[{{\bf A\+K\+\_\+header} $\ast$}]{header}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a79e7998e69e2910528f7ef258469b2be}{}\label{dbman_8c_a79e7998e69e2910528f7ef258469b2be}


Function that allocates new segment of extents. In this phase of implementation, only extents containing I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE blocks can be allocated. If extent is successfully allocated, number of allocated extents is incremented and function goes to next block after allocated extent. Otherwise, function moves to I\+N\+I\+T\+I\+A\+L\+\_\+\+E\+X\+T\+E\+N\+T\+\_\+\+S\+I\+ZE blocks. In that way function gets either first block of new extent or some block in that extent which will not be A\+K\+\_\+free. 

\begin{DoxyAuthor}{Author}
Tomislav Fotak, refurbished by dv 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em name} & (character pointer) name of segment \\
\hline
{\em type} & segment type (possible values\+: S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+S\+Y\+S\+T\+E\+M\+\_\+\+T\+A\+B\+LE, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+A\+B\+LE, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+N\+D\+EX, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+R\+A\+N\+S\+A\+C\+T\+I\+ON, S\+E\+G\+M\+E\+N\+T\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+E\+MP) \\
\hline
{\em header} & (header pointer) pointer to header that should be written to the new extent (all blocks) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS for success or E\+X\+I\+T\+\_\+\+E\+R\+R\+OR if some error occurs 
\end{DoxyReturn}
start address for segment because we can not allocate segment in block 0 \index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+print\+\_\+block@{A\+K\+\_\+print\+\_\+block}}
\index{A\+K\+\_\+print\+\_\+block@{A\+K\+\_\+print\+\_\+block}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+print\+\_\+block(\+A\+K\+\_\+block $\ast$block, int num, char $\ast$gg, F\+I\+L\+E $\ast$fpp)}{AK_print_block(AK_block *block, int num, char *gg, FILE *fpp)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+print\+\_\+block (
\begin{DoxyParamCaption}
\item[{{\bf A\+K\+\_\+block} $\ast$}]{block, }
\item[{int}]{num, }
\item[{char $\ast$}]{gg, }
\item[{F\+I\+LE $\ast$}]{fpp}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a3fcca519b1dbe309c683d64b0e955dca}{}\label{dbman_8c_a3fcca519b1dbe309c683d64b0e955dca}


Function that dumps block. 

\begin{DoxyAuthor}{Author}
dv 
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
nothing 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+read\+\_\+block@{A\+K\+\_\+read\+\_\+block}}
\index{A\+K\+\_\+read\+\_\+block@{A\+K\+\_\+read\+\_\+block}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+read\+\_\+block(int address)}{AK_read_block(int address)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf A\+K\+\_\+block}$\ast$ A\+K\+\_\+read\+\_\+block (
\begin{DoxyParamCaption}
\item[{int}]{address}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a2c880db7cf4f8332ae7e93c6b71cc911}{}\label{dbman_8c_a2c880db7cf4f8332ae7e93c6b71cc911}


Function that reads a block at a given address (block number less than db\+\_\+file\+\_\+size). New block is allocated. Database file is opened. Position is set to provided address block. At the end function reads file from that position. Completely thread-\/safe. 

\begin{DoxyAuthor}{Author}
Markus Schatten, updated dv and Domagoj Šitum (thread-\/safe enabled) 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em address} & block number (address) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to block allocated in memory 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing@{A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing}}
\index{A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing@{A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing(void $\ast$address)}{AK_read_block_for_testing(void *address)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ A\+K\+\_\+read\+\_\+block\+\_\+for\+\_\+testing (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{address}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a5499694bd97b104560d14ef70abe2c73}{}\label{dbman_8c_a5499694bd97b104560d14ef70abe2c73}


This function is only for testing. It has to be there, because pthread\+\_\+create only accepts void$\ast$ function\+\_\+name (void $\ast$) function format. So A\+K\+\_\+read\+\_\+block is no-\/go for pthread\+\_\+create. 

\begin{DoxyAuthor}{Author}
Domagoj Šitum 
\end{DoxyAuthor}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+register\+\_\+system\+\_\+tables@{A\+K\+\_\+register\+\_\+system\+\_\+tables}}
\index{A\+K\+\_\+register\+\_\+system\+\_\+tables@{A\+K\+\_\+register\+\_\+system\+\_\+tables}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+register\+\_\+system\+\_\+tables(int relation, int attribute, int index, int view, int sequence, int function, int function\+\_\+arguments, int trigger, int trigger\+\_\+conditions, int db, int db\+\_\+obj, int user, int group, int user\+\_\+group, int user\+\_\+right, int group\+\_\+right, int constraint, int constraint\+Null, int constraint\+Check, int constraint\+Unique, int reference)}{AK_register_system_tables(int relation, int attribute, int index, int view, int sequence, int function, int function_arguments, int trigger, int trigger_conditions, int db, int db_obj, int user, int group, int user_group, int user_right, int group_right, int constraint, int constraintNull, int constraintCheck, int constraintUnique, int reference)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+register\+\_\+system\+\_\+tables (
\begin{DoxyParamCaption}
\item[{int}]{relation, }
\item[{int}]{attribute, }
\item[{int}]{index, }
\item[{int}]{view, }
\item[{int}]{sequence, }
\item[{int}]{function, }
\item[{int}]{function\+\_\+arguments, }
\item[{int}]{trigger, }
\item[{int}]{trigger\+\_\+conditions, }
\item[{int}]{db, }
\item[{int}]{db\+\_\+obj, }
\item[{int}]{user, }
\item[{int}]{group, }
\item[{int}]{user\+\_\+group, }
\item[{int}]{user\+\_\+right, }
\item[{int}]{group\+\_\+right, }
\item[{int}]{constraint, }
\item[{int}]{constraint\+Null, }
\item[{int}]{constraint\+Check, }
\item[{int}]{constraint\+Unique, }
\item[{int}]{reference}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_af4c050534ddf6dcf1cba09987424ff76}{}\label{dbman_8c_af4c050534ddf6dcf1cba09987424ff76}


Function that registers system tables. Block at the given address is read. Various data from function arguments are written in block about different database elements. 

\begin{DoxyAuthor}{Author}
Unknown 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em relation} & relation in database \\
\hline
{\em attribute} & attribute in databse \\
\hline
{\em index} & index in database \\
\hline
{\em view} & view in database \\
\hline
{\em sequence} & sequence in database \\
\hline
{\em function} & function in database \\
\hline
{\em function\+\_\+arguments} & functional\+\_\+arguments in databse \\
\hline
{\em trigger} & trigger in database \\
\hline
{\em trigger\+\_\+conditions} & trigger conditions in databse \\
\hline
{\em db} & database \\
\hline
{\em db\+\_\+obj} & database object \\
\hline
{\em user} & user in database \\
\hline
{\em group} & group in database \\
\hline
{\em user\+\_\+group} & user associated with group in database \\
\hline
{\em user\+\_\+right} & user right in database \\
\hline
{\em group\+\_\+right} & group right in database \\
\hline
{\em constraint} & constraint in database \\
\hline
{\em constraint\+Null} & Null constraint in database \\
\hline
{\em constraint\+Check} & Check constraint in database \\
\hline
{\em reference} & reference database \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test@{A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test}}
\index{A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test@{A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test()}{AK_thread_safe_block_access_test()}}]{\setlength{\rightskip}{0pt plus 5cm}void A\+K\+\_\+thread\+\_\+safe\+\_\+block\+\_\+access\+\_\+test (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a41ad69e55d09ab4aa2bec6dd34805367}{}\label{dbman_8c_a41ad69e55d09ab4aa2bec6dd34805367}


This function tests thread safe reading and writing to blocks. There is N writing and N reading threads, which are going through iterations. Each reading thread should read the data (character) that was set by last writing thread. 

\begin{DoxyAuthor}{Author}
Domagoj Šitum 
\end{DoxyAuthor}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+write\+\_\+block@{A\+K\+\_\+write\+\_\+block}}
\index{A\+K\+\_\+write\+\_\+block@{A\+K\+\_\+write\+\_\+block}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+write\+\_\+block(\+A\+K\+\_\+block $\ast$block)}{AK_write_block(AK_block *block)}}]{\setlength{\rightskip}{0pt plus 5cm}int A\+K\+\_\+write\+\_\+block (
\begin{DoxyParamCaption}
\item[{{\bf A\+K\+\_\+block} $\ast$}]{block}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a222ea31aa276d52e464137a3b144f78a}{}\label{dbman_8c_a222ea31aa276d52e464137a3b144f78a}


Function writes a block to DB file. Database file is opened. Position is set to provided address block. Block is written to provided address. Completely thread-\/safe. 

\begin{DoxyAuthor}{Author}
Markus Schatten, updated by Domagoj Šitum (thread-\/safe enabled) 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em block} & poiner to block allocated in memory to write \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+X\+I\+T\+\_\+\+S\+U\+C\+C\+E\+SS if successful, E\+X\+I\+T\+\_\+\+E\+R\+R\+OR otherwise 
\end{DoxyReturn}
\index{dbman.\+c@{dbman.\+c}!A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing@{A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing}}
\index{A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing@{A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing(void $\ast$block)}{AK_write_block_for_testing(void *block)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ A\+K\+\_\+write\+\_\+block\+\_\+for\+\_\+testing (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{block}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_a0558e034eeed865a1c855de5cfad20ef}{}\label{dbman_8c_a0558e034eeed865a1c855de5cfad20ef}


This function is only for testing. It has to be there, because pthread\+\_\+create only accepts void$\ast$ function\+\_\+name (void $\ast$) function format. So A\+K\+\_\+write\+\_\+block is no-\/go for pthread\+\_\+create. 

\begin{DoxyAuthor}{Author}
Domagoj Šitum 
\end{DoxyAuthor}
\index{dbman.\+c@{dbman.\+c}!fsize@{fsize}}
\index{fsize@{fsize}!dbman.\+c@{dbman.\+c}}
\subsubsection[{\texorpdfstring{fsize(\+F\+I\+L\+E $\ast$fp)}{fsize(FILE *fp)}}]{\setlength{\rightskip}{0pt plus 5cm}int fsize (
\begin{DoxyParamCaption}
\item[{F\+I\+LE $\ast$}]{fp}
\end{DoxyParamCaption}
)}\hypertarget{dbman_8c_adbc6978517271fbd48a004cb039ac6c1}{}\label{dbman_8c_adbc6978517271fbd48a004cb039ac6c1}


Helper function to determine file size. 

\begin{DoxyReturn}{Returns}
file size 
\end{DoxyReturn}
