
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_fb6598a949f0f53f82ac9a1a956124c7.html">file</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fileio.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="fileio_8h_source.html">fileio.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for fileio.c:</div>
<div class="dyncontent">
<div class="center"><img src="fileio_8c__incl.png" border="0" usemap="#file_2fileio_8c" alt=""/></div>
<map name="file_2fileio_8c" id="file_2fileio_8c">
<area shape="rect" id="node2" href="fileio_8h.html" title="fileio.h" alt="" coords="679,80,746,107"/>
<area shape="rect" id="node3" href="constants_8h.html" title="../auxi/constants.h" alt="" coords="1118,752,1259,779"/>
<area shape="rect" id="node4" href="reference_8h.html" title="../sql/cs/reference.h" alt="" coords="194,379,343,405"/>
<area shape="rect" id="node15" href="mempro_8h.html" title="mempro.h" alt="" coords="1036,976,1125,1003"/>
<area shape="rect" id="node29" href="memoman_8h.html" title="../mm/memoman.h" alt="" coords="619,528,766,555"/>
<area shape="rect" id="node30" href="recovery_8h_source.html" title="../rec/recovery.h" alt="" coords="1119,155,1245,181"/>
<area shape="rect" id="node31" href="archive__log_8h.html" title="../rec/archive_log.h" alt="" coords="891,379,1036,405"/>
<area shape="rect" id="node33" href="files_8h.html" title="files.h" alt="" coords="5,304,68,331"/>
<area shape="rect" id="node37" href="redo__log_8h_source.html" title="../rec/redo_log.h" alt="" coords="1608,304,1735,331"/>
<area shape="rect" id="node5" href="dbman_8h.html" title="../../dm/dbman.h" alt="" coords="798,603,926,629"/>
<area shape="rect" id="node28" href="table_8h.html" title="../../file/table.h" alt="" coords="323,453,439,480"/>
<area shape="rect" id="node6" href="auxiliary_8h.html" title="../auxi/auxiliary.h" alt="" coords="1473,677,1608,704"/>
<area shape="rect" id="node7" href="configuration_8h_source.html" title="configuration.h" alt="" coords="1886,752,2006,779"/>
<area shape="rect" id="node21" href="debug_8h.html" title="debug.h" alt="" coords="1487,901,1562,928"/>
<area shape="rect" id="node8" href="iniparser_8h.html" title="Parser for ini files. " alt="" coords="1919,827,2010,853"/>
<area shape="rect" id="node13" href="dictionary_8h.html" title="Implements a dictionary for string variables. " alt="" coords="1949,901,2047,928"/>
<area shape="rect" id="node32" href="test_8h.html" title="../file/test.h" alt="" coords="899,229,995,256"/>
<area shape="rect" id="node35" href="rel__eq__selection_8h.html" title="../opti/rel_eq_selection.h" alt="" coords="469,379,650,405"/>
<area shape="rect" id="node34" href="id_8h.html" title="id.h" alt="" coords="72,379,119,405"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad2e954029e28dcf3149c6d9a76b960ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fileio_8c.html#ad2e954029e28dcf3149c6d9a76b960ab">Ak_Insert_New_Element_For_Update</a> (int newtype, void *data, char *table, char *attribute_name, struct <a class="el" href="structlist__node.html">list_node</a> *ElementBefore, int newconstraint)</td></tr>
<tr class="memdesc:ad2e954029e28dcf3149c6d9a76b960ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function inserts new element after some element, to insert on first place give list as before element. New element is allocated. Type, data, attribute name and constraint of new elemets are set according to function arguments. Pointers are changed so that before element points to new element.  <a href="#ad2e954029e28dcf3149c6d9a76b960ab">More...</a><br /></td></tr>
<tr class="separator:ad2e954029e28dcf3149c6d9a76b960ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f99778d1325dba20d27bfee2fe106c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fileio_8c.html#ad2f99778d1325dba20d27bfee2fe106c">Ak_Insert_New_Element</a> (int newtype, void *data, char *table, char *attribute_name, struct <a class="el" href="structlist__node.html">list_node</a> *ElementBefore)</td></tr>
<tr class="memdesc:ad2f99778d1325dba20d27bfee2fe106c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function inserts new element after some element, to insert on first place give list as before element. It calls function Ak_Insert_New_Element_For_Update.  <a href="#ad2f99778d1325dba20d27bfee2fe106c">More...</a><br /></td></tr>
<tr class="separator:ad2f99778d1325dba20d27bfee2fe106c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8823cd141c46ebbf9ea6299a0ea15e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fileio_8c.html#ab8823cd141c46ebbf9ea6299a0ea15e7">Ak_insert_row_to_block</a> (struct <a class="el" href="structlist__node.html">list_node</a> *row_root, <a class="el" href="structAK__block.html">AK_block</a> *temp_block)</td></tr>
<tr class="memdesc:ab8823cd141c46ebbf9ea6299a0ea15e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function inserts one row into some block. Firstly it checks wether block contain attributes from the list. Then data, type, size and last_tuple_id are put in temp_block.  <a href="#ab8823cd141c46ebbf9ea6299a0ea15e7">More...</a><br /></td></tr>
<tr class="separator:ab8823cd141c46ebbf9ea6299a0ea15e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f0975e1d6d62009b5c9190e9e4be28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fileio_8c.html#a83f0975e1d6d62009b5c9190e9e4be28">Ak_insert_row</a> (struct <a class="el" href="structlist__node.html">list_node</a> *row_root)</td></tr>
<tr class="memdesc:a83f0975e1d6d62009b5c9190e9e4be28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function inserts a one row into table. Firstly it is checked whether inserted row would violite reference integrity. Then it is checked in which table should row be inserted. If there is no AK_free space for new table, new extent is allocated. New block is allocated on given address. Row is inserted in this block and dirty flag is set to BLOCK_DIRTY.  <a href="#a83f0975e1d6d62009b5c9190e9e4be28">More...</a><br /></td></tr>
<tr class="separator:a83f0975e1d6d62009b5c9190e9e4be28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8bf2505b4e89f56a3d8b52ce53abcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fileio_8c.html#a2b8bf2505b4e89f56a3d8b52ce53abcd">Ak_update_row_from_block</a> (<a class="el" href="structAK__block.html">AK_block</a> *temp_block, struct <a class="el" href="structlist__node.html">list_node</a> *row_root)</td></tr>
<tr class="memdesc:a2b8bf2505b4e89f56a3d8b52ce53abcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function updates row from table in given block.  <a href="#a2b8bf2505b4e89f56a3d8b52ce53abcd">More...</a><br /></td></tr>
<tr class="separator:a2b8bf2505b4e89f56a3d8b52ce53abcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755a70a5797e3db8cc0aa90ef77530df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fileio_8c.html#a755a70a5797e3db8cc0aa90ef77530df">Ak_delete_row_from_block</a> (<a class="el" href="structAK__block.html">AK_block</a> *temp_block, struct <a class="el" href="structlist__node.html">list_node</a> *row_root)</td></tr>
<tr class="memdesc:a755a70a5797e3db8cc0aa90ef77530df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function deletes row from table in given block. Given list of elements is firstly back-upped.  <a href="#a755a70a5797e3db8cc0aa90ef77530df">More...</a><br /></td></tr>
<tr class="separator:a755a70a5797e3db8cc0aa90ef77530df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9646847cea4944eafebbe482f15f4906"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fileio_8c.html#a9646847cea4944eafebbe482f15f4906">Ak_delete_update_segment</a> (struct <a class="el" href="structlist__node.html">list_node</a> *row_root, int del)</td></tr>
<tr class="memdesc:a9646847cea4944eafebbe482f15f4906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function updates or deletes the whole segment of an table. Addresses for given table atr fetched. For each block in extent row is updated or deleted according to operator del.  <a href="#a9646847cea4944eafebbe482f15f4906">More...</a><br /></td></tr>
<tr class="separator:a9646847cea4944eafebbe482f15f4906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7b8d65fef8057c0b47502606a34994"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fileio_8c.html#afa7b8d65fef8057c0b47502606a34994">Ak_delete_row</a> (struct <a class="el" href="structlist__node.html">list_node</a> *row_root)</td></tr>
<tr class="memdesc:afa7b8d65fef8057c0b47502606a34994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function deletes rows.  <a href="#afa7b8d65fef8057c0b47502606a34994">More...</a><br /></td></tr>
<tr class="separator:afa7b8d65fef8057c0b47502606a34994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f898bae229173c6f8afed9e2ef0ed7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fileio_8c.html#ad6f898bae229173c6f8afed9e2ef0ed7">Ak_delete_row_by_id</a> (int id, char *tableName)</td></tr>
<tr class="memdesc:ad6f898bae229173c6f8afed9e2ef0ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function deletes row by id.  <a href="#ad6f898bae229173c6f8afed9e2ef0ed7">More...</a><br /></td></tr>
<tr class="separator:ad6f898bae229173c6f8afed9e2ef0ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978a5fc0afeea6ec045977d886647ae3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fileio_8c.html#a978a5fc0afeea6ec045977d886647ae3">Ak_update_row</a> (struct <a class="el" href="structlist__node.html">list_node</a> *row_root)</td></tr>
<tr class="memdesc:a978a5fc0afeea6ec045977d886647ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function updates rows of some table.  <a href="#a978a5fc0afeea6ec045977d886647ae3">More...</a><br /></td></tr>
<tr class="separator:a978a5fc0afeea6ec045977d886647ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5cad3ac448141051a67564647cc621"><td class="memItemLeft" align="right" valign="top"><a id="a1b5cad3ac448141051a67564647cc621"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Ak_fileio_test</b> ()</td></tr>
<tr class="separator:a1b5cad3ac448141051a67564647cc621"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides functions for file input/output </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="afa7b8d65fef8057c0b47502606a34994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7b8d65fef8057c0b47502606a34994">&#9670;&nbsp;</a></span>Ak_delete_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ak_delete_row </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>row_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function deletes rows. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, Dejan Frankovic (added referential integrity) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_root</td><td>elements of one row  EXIT_SUCCESS if success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6f898bae229173c6f8afed9e2ef0ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f898bae229173c6f8afed9e2ef0ed7">&#9670;&nbsp;</a></span>Ak_delete_row_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_delete_row_by_id </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tableName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function deletes row by id. </p>
<dl class="section author"><dt>Author</dt><dd>Dražen Bandić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of row </td></tr>
    <tr><td class="paramname">tableName</td><td>name of table to delete the row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a755a70a5797e3db8cc0aa90ef77530df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755a70a5797e3db8cc0aa90ef77530df">&#9670;&nbsp;</a></span>Ak_delete_row_from_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_delete_row_from_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td>
          <td class="paramname"><em>temp_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>row_root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function deletes row from table in given block. Given list of elements is firstly back-upped. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, updated by Dino Laktašić, changed by Davorin Vukelic, updated by Mario Peroković </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temp_block</td><td>block to work with </td></tr>
    <tr><td class="paramname">row_list</td><td>list of elements which contain data for delete or update </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
<a id="a9646847cea4944eafebbe482f15f4906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9646847cea4944eafebbe482f15f4906">&#9670;&nbsp;</a></span>Ak_delete_update_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ak_delete_update_segment </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>row_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>del</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function updates or deletes the whole segment of an table. Addresses for given table atr fetched. For each block in extent row is updated or deleted according to operator del. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, updated by Matija Šestak (function now uses caching) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_root</td><td>elements of one row </td></tr>
    <tr><td class="paramname">del</td><td>- DELETE or UPDATE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if success </dd></dl>

</div>
</div>
<a id="ad2f99778d1325dba20d27bfee2fe106c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f99778d1325dba20d27bfee2fe106c">&#9670;&nbsp;</a></span>Ak_Insert_New_Element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_Insert_New_Element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>ElementBefore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function inserts new element after some element, to insert on first place give list as before element. It calls function Ak_Insert_New_Element_For_Update. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, changed by Dino Laktašić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newtype</td><td>type of the data </td></tr>
    <tr><td class="paramname">data</td><td>the data </td></tr>
    <tr><td class="paramname">table</td><td>table name </td></tr>
    <tr><td class="paramname">attribute_name</td><td>attribute name </td></tr>
    <tr><td class="paramname">element</td><td>element after we which insert the new element </td></tr>
    <tr><td class="paramname">constraint</td><td>is NEW_VALUE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
<a id="ad2e954029e28dcf3149c6d9a76b960ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e954029e28dcf3149c6d9a76b960ab">&#9670;&nbsp;</a></span>Ak_Insert_New_Element_For_Update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_Insert_New_Element_For_Update </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>ElementBefore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newconstraint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function inserts new element after some element, to insert on first place give list as before element. New element is allocated. Type, data, attribute name and constraint of new elemets are set according to function arguments. Pointers are changed so that before element points to new element. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newtype</td><td>type of the data </td></tr>
    <tr><td class="paramname">data</td><td>the data </td></tr>
    <tr><td class="paramname">table</td><td>table name </td></tr>
    <tr><td class="paramname">attribute_name</td><td>attribute name </td></tr>
    <tr><td class="paramname">element</td><td>element after we which insert the new element </td></tr>
    <tr><td class="paramname">constraint</td><td>NEW_VALUE if data is new value, SEARCH_CONSTRAINT if data is constraint to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
<a id="a83f0975e1d6d62009b5c9190e9e4be28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f0975e1d6d62009b5c9190e9e4be28">&#9670;&nbsp;</a></span>Ak_insert_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ak_insert_row </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>row_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function inserts a one row into table. Firstly it is checked whether inserted row would violite reference integrity. Then it is checked in which table should row be inserted. If there is no AK_free space for new table, new extent is allocated. New block is allocated on given address. Row is inserted in this block and dirty flag is set to BLOCK_DIRTY. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, updated by Matija Šestak (function now uses caching), updated by Dejan Frankovic (added reference check), updated by Dino Laktašić (removed variable AK_free, variable table initialized using memset) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_root</td><td>list of elements which contain data of one row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if success else EXIT_ERROR </dd></dl>

</div>
</div>
<a id="ab8823cd141c46ebbf9ea6299a0ea15e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8823cd141c46ebbf9ea6299a0ea15e7">&#9670;&nbsp;</a></span>Ak_insert_row_to_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ak_insert_row_to_block </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>row_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td>
          <td class="paramname"><em>temp_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function inserts one row into some block. Firstly it checks wether block contain attributes from the list. Then data, type, size and last_tuple_id are put in temp_block. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, updated by Dino Laktašić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_root</td><td>list of elements to insert </td></tr>
    <tr><td class="paramname">temp_block</td><td>block in which we insert data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT SUCCES if success </dd></dl>

</div>
</div>
<a id="a978a5fc0afeea6ec045977d886647ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978a5fc0afeea6ec045977d886647ae3">&#9670;&nbsp;</a></span>Ak_update_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ak_update_row </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>row_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function updates rows of some table. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, Dejan Frankovic (added referential integrity) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_root</td><td>elements of one row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if success </dd></dl>

</div>
</div>
<a id="a2b8bf2505b4e89f56a3d8b52ce53abcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8bf2505b4e89f56a3d8b52ce53abcd">&#9670;&nbsp;</a></span>Ak_update_row_from_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_update_row_from_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td>
          <td class="paramname"><em>temp_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>row_root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function updates row from table in given block. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, updated by Dino Laktašić, updated by Mario Peroković - separated from deletion </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temp_block</td><td>block to work with </td></tr>
    <tr><td class="paramname">row_list</td><td>list of elements which contain data for delete or update </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
</div><!-- contents -->

