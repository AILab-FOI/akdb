
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_55aed34cd3f6ec638757940cb3108f99.html">auxi</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">auxiliary.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="constants_8h_source.html">constants.h</a>&quot;</code><br />
<code>#include &quot;configuration.h&quot;</code><br />
<code>#include &quot;assert.h&quot;</code><br />
<code>#include &quot;time.h&quot;</code><br />
<code>#include &quot;string.h&quot;</code><br />
<code>#include &quot;ctype.h&quot;</code><br />
<code>#include &quot;<a class="el" href="debug_8h_source.html">debug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mempro_8h_source.html">mempro.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for auxiliary.h:</div>
<div class="dyncontent">
<div class="center"><img src="auxiliary_8h__incl.png" border="0" usemap="#auxi_2auxiliary_8h" alt=""/></div>
<map name="auxi_2auxiliary_8h" id="auxi_2auxiliary_8h">
<area shape="rect" id="node2" href="constants_8h.html" title="constants.h" alt="" coords="5,80,103,107"/>
<area shape="rect" id="node3" href="configuration_8h_source.html" title="configuration.h" alt="" coords="515,80,635,107"/>
<area shape="rect" id="node11" href="mempro_8h.html" title="mempro.h" alt="" coords="683,304,772,331"/>
<area shape="rect" id="node17" href="debug_8h.html" title="debug.h" alt="" coords="647,229,722,256"/>
<area shape="rect" id="node4" href="iniparser_8h.html" title="Parser for ini files. " alt="" coords="455,155,546,181"/>
<area shape="rect" id="node9" href="dictionary_8h.html" title="Implements a dictionary for string variables. " alt="" coords="365,229,463,256"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="auxiliary_8h__dep__incl.png" border="0" usemap="#auxi_2auxiliary_8hdep" alt=""/></div>
<map name="auxi_2auxiliary_8hdep" id="auxi_2auxiliary_8hdep">
<area shape="rect" id="node2" href="auxiliary_8c.html" title="auxi/auxiliary.c" alt="" coords="5,80,128,107"/>
<area shape="rect" id="node3" href="dbman_8h.html" title="dm/dbman.h" alt="" coords="732,80,836,107"/>
<area shape="rect" id="node12" href="recovery_8h_source.html" title="rec/recovery.h" alt="" coords="313,453,428,480"/>
<area shape="rect" id="node26" href="test_8c.html" title="file/test.c" alt="" coords="3260,752,3343,779"/>
<area shape="rect" id="node29" href="select_8h_source.html" title="sql/select.h" alt="" coords="1068,603,1164,629"/>
<area shape="rect" id="node36" href="function_8h.html" title="sql/function.h" alt="" coords="2869,453,2979,480"/>
<area shape="rect" id="node42" href="redo__log_8h_source.html" title="rec/redo_log.h" alt="" coords="775,304,889,331"/>
<area shape="rect" id="node44" href="rel__eq__comut_8h.html" title="opti/rel_eq_comut.h" alt="" coords="3189,304,3339,331"/>
<area shape="rect" id="node46" href="rel__eq__assoc_8h.html" title="opti/rel_eq_assoc.h" alt="" coords="3389,304,3536,331"/>
<area shape="rect" id="node49" href="rel__eq__projection_8c.html" title="opti/rel_eq_projection.c" alt="" coords="3687,80,3862,107"/>
<area shape="rect" id="node50" href="rel__eq__selection_8c.html" title="opti/rel_eq_selection.c" alt="" coords="3887,80,4055,107"/>
<area shape="rect" id="node4" href="dbman_8c.html" title="dm/dbman.c" alt="" coords="733,155,835,181"/>
<area shape="rect" id="node5" href="memoman_8h.html" title="mm/memoman.h" alt="" coords="525,155,659,181"/>
<area shape="rect" id="node9" href="blobs_8c.html" title="file/blobs.c" alt="" coords="364,603,457,629"/>
<area shape="rect" id="node10" href="reference_8h.html" title="sql/cs/reference.h" alt="" coords="965,304,1102,331"/>
<area shape="rect" id="node6" href="memoman_8c.html" title="mm/memoman.c" alt="" coords="679,229,814,256"/>
<area shape="rect" id="node7" href="table_8h.html" title="file/table.h" alt="" coords="1890,229,1982,256"/>
<area shape="rect" id="node11" href="fileio_8h.html" title="file/fileio.h" alt="" coords="1518,379,1610,405"/>
<area shape="rect" id="node17" href="between_8h.html" title="sql/cs/between.h" alt="" coords="465,528,596,555"/>
<area shape="rect" id="node23" href="filesort_8h.html" title="file/filesort.h" alt="" coords="503,453,609,480"/>
<area shape="rect" id="node25" href="transaction_8h.html" title="trans/transaction.h" alt="" coords="812,677,956,704"/>
<area shape="rect" id="node30" href="select_8c.html" title="sql/select.c" alt="" coords="1025,677,1119,704"/>
<area shape="rect" id="node34" href="bitmap_8h.html" title="file/idx/bitmap.h" alt="" coords="1178,528,1307,555"/>
<area shape="rect" id="node48" href="filesearch_8h.html" title="file/filesearch.h" alt="" coords="481,229,604,256"/>
<area shape="rect" id="node8" href="blobs_8h.html" title="file/blobs.h" alt="" coords="743,528,838,555"/>
<area shape="rect" id="node14" href="id_8h.html" title="file/id.h" alt="" coords="2519,453,2590,480"/>
<area shape="rect" id="node15" href="sequence_8h.html" title="file/sequence.h" alt="" coords="2473,528,2594,555"/>
<area shape="rect" id="node16" href="drop_8h.html" title="sql/drop.h" alt="" coords="2635,677,2722,704"/>
<area shape="rect" id="node18" href="view_8h_source.html" title="sql/view.h" alt="" coords="3100,528,3188,555"/>
<area shape="rect" id="node20" href="trigger_8h.html" title="sql/trigger.h" alt="" coords="2411,603,2511,629"/>
<area shape="rect" id="node21" href="privileges_8h_source.html" title="sql/privileges.h" alt="" coords="2618,528,2739,555"/>
<area shape="rect" id="node24" href="command_8h_source.html" title="sql/command.h" alt="" coords="921,603,1044,629"/>
<area shape="rect" id="node27" href="expression__check_8h.html" title="rel/expression_check.h" alt="" coords="1140,453,1311,480"/>
<area shape="rect" id="node31" href="check__constraint_8h.html" title="sql/cs/check_constraint.h" alt="" coords="1331,528,1517,555"/>
<area shape="rect" id="node32" href="projection_8h.html" title="rel/projection.h" alt="" coords="1592,528,1712,555"/>
<area shape="rect" id="node33" href="index_8h.html" title="file/idx/index.h" alt="" coords="1703,453,1822,480"/>
<area shape="rect" id="node35" href="index_8c.html" title="file/idx/index.c" alt="" coords="1851,528,1970,555"/>
<area shape="rect" id="node38" href="constraint__names_8h.html" title="sql/cs/constraint_names.h" alt="" coords="2101,453,2291,480"/>
<area shape="rect" id="node39" href="nnull_8h.html" title="sql/cs/nnull.h" alt="" coords="2009,528,2116,555"/>
<area shape="rect" id="node40" href="unique_8h.html" title="sql/cs/unique.h" alt="" coords="2227,528,2346,555"/>
<area shape="rect" id="node41" href="reference_8c.html" title="sql/cs/reference.c" alt="" coords="965,379,1101,405"/>
<area shape="rect" id="node22" href="fileio_8c.html" title="file/fileio.c" alt="" coords="1335,453,1425,480"/>
<area shape="rect" id="node13" href="recovery_8c.html" title="rec/recovery.c" alt="" coords="313,528,428,555"/>
<area shape="rect" id="node19" href="query__optimization_8h.html" title="opti/query_optimization.h" alt="" coords="3364,603,3553,629"/>
<area shape="rect" id="node28" href="selection_8h.html" title="rel/selection.h" alt="" coords="1039,528,1153,555"/>
<area shape="rect" id="node37" href="function_8c.html" title="sql/function.c" alt="" coords="2916,528,3025,555"/>
<area shape="rect" id="node43" href="redo__log_8c.html" title="rec/redo_log.c" alt="" coords="775,379,889,405"/>
<area shape="rect" id="node45" href="rel__eq__comut_8c.html" title="opti/rel_eq_comut.c" alt="" coords="3138,379,3289,405"/>
<area shape="rect" id="node47" href="rel__eq__assoc_8c.html" title="opti/rel_eq_assoc.c" alt="" coords="3415,379,3561,405"/>
</map>
</div>
</div>
<p><a href="auxiliary_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlist__node.html">list_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure defines a list node.  <a href="structlist__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVertex.html">Vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure defines a <a class="el" href="structVertex.html" title="Structure defines a Vertex node element. Every Vertex has its VertexId, index, lowLink and pointer to...">Vertex</a> node element. Every <a class="el" href="structVertex.html" title="Structure defines a Vertex node element. Every Vertex has its VertexId, index, lowLink and pointer to...">Vertex</a> has its VertexId, index, lowLink and pointer to next edge and vertex.  <a href="structVertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSuccesor.html">Succesor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure defines a <a class="el" href="structSuccesor.html" title="Structure defines a Succesor element. Every Succesor has its Vertex pointer and pointer to next Succe...">Succesor</a> element. Every <a class="el" href="structSuccesor.html" title="Structure defines a Succesor element. Every Succesor has its Vertex pointer and pointer to next Succe...">Succesor</a> has its <a class="el" href="structVertex.html" title="Structure defines a Vertex node element. Every Vertex has its VertexId, index, lowLink and pointer to...">Vertex</a> pointer and pointer to next <a class="el" href="structSuccesor.html" title="Structure defines a Succesor element. Every Succesor has its Vertex pointer and pointer to next Succe...">Succesor</a> in the linked list.  <a href="structSuccesor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structStack.html">Stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure defines a <a class="el" href="structStack.html" title="Structure defines a Stack element. Every Stack has its Vertex pointer and pointer to next Stack in th...">Stack</a> element. Every <a class="el" href="structStack.html" title="Structure defines a Stack element. Every Stack has its Vertex pointer and pointer to next Stack in th...">Stack</a> has its <a class="el" href="structVertex.html" title="Structure defines a Vertex node element. Every Vertex has its VertexId, index, lowLink and pointer to...">Vertex</a> pointer and pointer to next <a class="el" href="structStack.html" title="Structure defines a Stack element. Every Stack has its Vertex pointer and pointer to next Stack in th...">Stack</a> in the linked list.  <a href="structStack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAK__synchronization__info.html">AK_synchronization_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for managing the synchronization between multiple threads accessing the same resources (essentially a mutex).  <a href="structAK__synchronization__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1b91aef3bbc2ad3ed72b00e924d001e9"><td class="memItemLeft" align="right" valign="top"><a id="a1b91aef3bbc2ad3ed72b00e924d001e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_LOOP_ITERATIONS</b>&#160;&#160;&#160;1000</td></tr>
<tr class="separator:a1b91aef3bbc2ad3ed72b00e924d001e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e654610e22a288ddb862be722ab7dc5"><td class="memItemLeft" align="right" valign="top"><a id="a2e654610e22a288ddb862be722ab7dc5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TBL_BOX_OFFSET</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a2e654610e22a288ddb862be722ab7dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac20d11997484967989abf1772f30d5a0"><td class="memItemLeft" align="right" valign="top"><a id="ac20d11997484967989abf1772f30d5a0"></a>
typedef struct <a class="el" href="structlist__node.html">list_node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AK_list</b></td></tr>
<tr class="separator:ac20d11997484967989abf1772f30d5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4e8ff8ccb4898b092c63ad8553390a"><td class="memItemLeft" align="right" valign="top"><a id="a9a4e8ff8ccb4898b092c63ad8553390a"></a>
typedef struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>AK_list_elem</b></td></tr>
<tr class="separator:a9a4e8ff8ccb4898b092c63ad8553390a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12da3ddba1476cfb2c08c9206938c42"><td class="memItemLeft" align="right" valign="top"><a id="aa12da3ddba1476cfb2c08c9206938c42"></a>
typedef struct <a class="el" href="structVertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AK_graph</b></td></tr>
<tr class="separator:aa12da3ddba1476cfb2c08c9206938c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6987e2a4fac104b50cb9348010a87b5"><td class="memItemLeft" align="right" valign="top"><a id="ac6987e2a4fac104b50cb9348010a87b5"></a>
typedef struct <a class="el" href="structSuccesor.html">Succesor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>AK_succesor</b></td></tr>
<tr class="separator:ac6987e2a4fac104b50cb9348010a87b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811229ac9ce9804e90f3edda321d37ba"><td class="memItemLeft" align="right" valign="top"><a id="a811229ac9ce9804e90f3edda321d37ba"></a>
typedef struct <a class="el" href="structVertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>AK_vertex</b></td></tr>
<tr class="separator:a811229ac9ce9804e90f3edda321d37ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908b8f87555962274331f97221b195df"><td class="memItemLeft" align="right" valign="top"><a id="a908b8f87555962274331f97221b195df"></a>
typedef struct <a class="el" href="structStack.html">Stack</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>AK_stack</b></td></tr>
<tr class="separator:a908b8f87555962274331f97221b195df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12e3fd5d8e508ea96098866e12a81a8"><td class="memItemLeft" align="right" valign="top"><a id="ab12e3fd5d8e508ea96098866e12a81a8"></a>
typedef struct <a class="el" href="structStack.html">Stack</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AK_stackHead</b></td></tr>
<tr class="separator:ab12e3fd5d8e508ea96098866e12a81a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7ef0a3434550001b2aa3364e4018a917"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a7ef0a3434550001b2aa3364e4018a917">AK_strcmp</a> (const void *a, const void *b)</td></tr>
<tr class="memdesc:a7ef0a3434550001b2aa3364e4018a917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function compares to Strings.  <a href="#a7ef0a3434550001b2aa3364e4018a917">More...</a><br /></td></tr>
<tr class="separator:a7ef0a3434550001b2aa3364e4018a917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d24287a0675367a7129512792f1ad7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a19d24287a0675367a7129512792f1ad7">AK_chars_num_from_number</a> (int number, int base)</td></tr>
<tr class="memdesc:a19d24287a0675367a7129512792f1ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function gets number of digits for given number.  <a href="#a19d24287a0675367a7129512792f1ad7">More...</a><br /></td></tr>
<tr class="separator:a19d24287a0675367a7129512792f1ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c96419e17650737bae8af0dfdb399f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a46c96419e17650737bae8af0dfdb399f">AK_type_size</a> (int iDB_type, char *szVarchar)</td></tr>
<tr class="memdesc:a46c96419e17650737bae8af0dfdb399f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returns size in bytes of the provided database type.  <a href="#a46c96419e17650737bae8af0dfdb399f">More...</a><br /></td></tr>
<tr class="separator:a46c96419e17650737bae8af0dfdb399f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e977cbb8ef0cc8fc7ec3c28ea010f6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a1e977cbb8ef0cc8fc7ec3c28ea010f6f">Ak_Init_L3</a> (struct <a class="el" href="structlist__node.html">list_node</a> **L)</td></tr>
<tr class="memdesc:a1e977cbb8ef0cc8fc7ec3c28ea010f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function initializes empty list.  <a href="#a1e977cbb8ef0cc8fc7ec3c28ea010f6f">More...</a><br /></td></tr>
<tr class="separator:a1e977cbb8ef0cc8fc7ec3c28ea010f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b30c1bcfcb82c8f460db1e9d04b3ee"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#af4b30c1bcfcb82c8f460db1e9d04b3ee">Ak_First_L2</a> (struct <a class="el" href="structlist__node.html">list_node</a> *L)</td></tr>
<tr class="memdesc:af4b30c1bcfcb82c8f460db1e9d04b3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function gets the first element of the list.  <a href="#af4b30c1bcfcb82c8f460db1e9d04b3ee">More...</a><br /></td></tr>
<tr class="separator:af4b30c1bcfcb82c8f460db1e9d04b3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc800c852871e9a9a3ed59736e1324e3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#adc800c852871e9a9a3ed59736e1324e3">Ak_End_L2</a> (struct <a class="el" href="structlist__node.html">list_node</a> *L)</td></tr>
<tr class="memdesc:adc800c852871e9a9a3ed59736e1324e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function gets the last element of the list.  <a href="#adc800c852871e9a9a3ed59736e1324e3">More...</a><br /></td></tr>
<tr class="separator:adc800c852871e9a9a3ed59736e1324e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b623eddf3baccd6b792e460d23b9145"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a9b623eddf3baccd6b792e460d23b9145">Ak_Next_L2</a> (struct <a class="el" href="structlist__node.html">list_node</a> *current)</td></tr>
<tr class="memdesc:a9b623eddf3baccd6b792e460d23b9145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function gets the next element of the list.  <a href="#a9b623eddf3baccd6b792e460d23b9145">More...</a><br /></td></tr>
<tr class="separator:a9b623eddf3baccd6b792e460d23b9145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3256c93947b5866b09f76abd953a86d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#ab3256c93947b5866b09f76abd953a86d">Ak_Previous_L2</a> (struct <a class="el" href="structlist__node.html">list_node</a> *current, struct <a class="el" href="structlist__node.html">list_node</a> *L)</td></tr>
<tr class="memdesc:ab3256c93947b5866b09f76abd953a86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function gets the previous element of the list.  <a href="#ab3256c93947b5866b09f76abd953a86d">More...</a><br /></td></tr>
<tr class="separator:ab3256c93947b5866b09f76abd953a86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3331f9738966d0474068e676432fb69"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#aa3331f9738966d0474068e676432fb69">Ak_IsEmpty_L2</a> (struct <a class="el" href="structlist__node.html">list_node</a> *L)</td></tr>
<tr class="memdesc:aa3331f9738966d0474068e676432fb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function tests whether the list is empty.  <a href="#aa3331f9738966d0474068e676432fb69">More...</a><br /></td></tr>
<tr class="separator:aa3331f9738966d0474068e676432fb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54bcef3f0e783a9bcebc1ca646e89c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#ac54bcef3f0e783a9bcebc1ca646e89c6">Ak_InsertBefore_L2</a> (int type, char *data, int size, struct <a class="el" href="structlist__node.html">list_node</a> **current, struct <a class="el" href="structlist__node.html">list_node</a> **L)</td></tr>
<tr class="memdesc:ac54bcef3f0e783a9bcebc1ca646e89c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function inserts new element before the current element in the list.  <a href="#ac54bcef3f0e783a9bcebc1ca646e89c6">More...</a><br /></td></tr>
<tr class="separator:ac54bcef3f0e783a9bcebc1ca646e89c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2d039355d7a1087da132ca726ddaa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a9c2d039355d7a1087da132ca726ddaa6">Ak_InsertAfter_L2</a> (int type, char *data, int size, struct <a class="el" href="structlist__node.html">list_node</a> **current, struct <a class="el" href="structlist__node.html">list_node</a> **L)</td></tr>
<tr class="memdesc:a9c2d039355d7a1087da132ca726ddaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function inserts new element after the current element in the list.  <a href="#a9c2d039355d7a1087da132ca726ddaa6">More...</a><br /></td></tr>
<tr class="separator:a9c2d039355d7a1087da132ca726ddaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288037153643c201561326d464a274cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a288037153643c201561326d464a274cd">Ak_InsertAtBegin_L3</a> (int type, char *data, int size, struct <a class="el" href="structlist__node.html">list_node</a> *L)</td></tr>
<tr class="memdesc:a288037153643c201561326d464a274cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function inserts new element at the begin of the list. It uses function AK_InsertBefore_L.  <a href="#a288037153643c201561326d464a274cd">More...</a><br /></td></tr>
<tr class="separator:a288037153643c201561326d464a274cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b85b3038e088b9a1609b1ec173dc81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a44b85b3038e088b9a1609b1ec173dc81">Ak_InsertAtEnd_L3</a> (int type, char *data, int size, struct <a class="el" href="structlist__node.html">list_node</a> *L)</td></tr>
<tr class="memdesc:a44b85b3038e088b9a1609b1ec173dc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function inserts new element at the end of the list. It uses function Ak_InsertAfter_L2.  <a href="#a44b85b3038e088b9a1609b1ec173dc81">More...</a><br /></td></tr>
<tr class="separator:a44b85b3038e088b9a1609b1ec173dc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16de3836bf0893fef80fac125e07575b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a16de3836bf0893fef80fac125e07575b">Ak_Delete_L3</a> (struct <a class="el" href="structlist__node.html">list_node</a> **current, struct <a class="el" href="structlist__node.html">list_node</a> **L)</td></tr>
<tr class="memdesc:a16de3836bf0893fef80fac125e07575b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function deletes the current element in the list.  <a href="#a16de3836bf0893fef80fac125e07575b">More...</a><br /></td></tr>
<tr class="separator:a16de3836bf0893fef80fac125e07575b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6886d2e3b64e632490214a10ff750df1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a6886d2e3b64e632490214a10ff750df1">Ak_DeleteAll_L3</a> (struct <a class="el" href="structlist__node.html">list_node</a> **L)</td></tr>
<tr class="memdesc:a6886d2e3b64e632490214a10ff750df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function empties list.  <a href="#a6886d2e3b64e632490214a10ff750df1">More...</a><br /></td></tr>
<tr class="separator:a6886d2e3b64e632490214a10ff750df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea432955394feccab4cb8175bf616214"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#aea432955394feccab4cb8175bf616214">Ak_Size_L2</a> (struct <a class="el" href="structlist__node.html">list_node</a> *L)</td></tr>
<tr class="memdesc:aea432955394feccab4cb8175bf616214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function gets a number of the elements in the list.  <a href="#aea432955394feccab4cb8175bf616214">More...</a><br /></td></tr>
<tr class="separator:aea432955394feccab4cb8175bf616214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fee7fbe9ba42288d7376b95c6f1afe"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a87fee7fbe9ba42288d7376b95c6f1afe">Ak_Retrieve_L2</a> (struct <a class="el" href="structlist__node.html">list_node</a> *current, struct <a class="el" href="structlist__node.html">list_node</a> *L)</td></tr>
<tr class="memdesc:a87fee7fbe9ba42288d7376b95c6f1afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function retrieves data from the current element in the list.  <a href="#a87fee7fbe9ba42288d7376b95c6f1afe">More...</a><br /></td></tr>
<tr class="separator:a87fee7fbe9ba42288d7376b95c6f1afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ed0f3a83949f98c6d2b00bbb3f394d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a96ed0f3a83949f98c6d2b00bbb3f394d">Ak_GetNth_L2</a> (int pos, struct <a class="el" href="structlist__node.html">list_node</a> *row)</td></tr>
<tr class="memdesc:a96ed0f3a83949f98c6d2b00bbb3f394d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function gets a type of the current list element.  <a href="#a96ed0f3a83949f98c6d2b00bbb3f394d">More...</a><br /></td></tr>
<tr class="separator:a96ed0f3a83949f98c6d2b00bbb3f394d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f8f33ba4112d99a87e6d653ec6fd4f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#ad2f8f33ba4112d99a87e6d653ec6fd4f">AK_get_array_perms</a> (char *arr)</td></tr>
<tr class="memdesc:ad2f8f33ba4112d99a87e6d653ec6fd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function gets the position of given element.  <a href="#ad2f8f33ba4112d99a87e6d653ec6fd4f">More...</a><br /></td></tr>
<tr class="separator:ad2f8f33ba4112d99a87e6d653ec6fd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5f350b143545f5fbe03da908bf9327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVertex.html">AK_vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a6f5f350b143545f5fbe03da908bf9327">AK_search_vertex</a> (int id)</td></tr>
<tr class="separator:a6f5f350b143545f5fbe03da908bf9327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae087a85c200788e13f21d82561b11b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVertex.html">AK_vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#ae087a85c200788e13f21d82561b11b11">AK_search_empty_link</a> ()</td></tr>
<tr class="separator:ae087a85c200788e13f21d82561b11b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2feed473ff20bcbf39f2552745231c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVertex.html">AK_vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#abb2feed473ff20bcbf39f2552745231c">AK_add_vertex</a> (int id)</td></tr>
<tr class="memdesc:abb2feed473ff20bcbf39f2552745231c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that adds a new graph node.  <a href="#abb2feed473ff20bcbf39f2552745231c">More...</a><br /></td></tr>
<tr class="separator:abb2feed473ff20bcbf39f2552745231c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e572792d5472a716c26ef3c4640763"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSuccesor.html">AK_succesor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#aa5e572792d5472a716c26ef3c4640763">AK_add_succesor</a> (int succesorId, int succesorOf)</td></tr>
<tr class="memdesc:aa5e572792d5472a716c26ef3c4640763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a edge between two nodes.  <a href="#aa5e572792d5472a716c26ef3c4640763">More...</a><br /></td></tr>
<tr class="separator:aa5e572792d5472a716c26ef3c4640763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b6e5ca13818d030a47748ddeda6aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structStack.html">AK_stack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#aa3b6e5ca13818d030a47748ddeda6aec">AK_search_empty_stack_link</a> (<a class="el" href="structStack.html">AK_stack</a> stackRoot)</td></tr>
<tr class="memdesc:aa3b6e5ca13818d030a47748ddeda6aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a empty link for the stack.  <a href="#aa3b6e5ca13818d030a47748ddeda6aec">More...</a><br /></td></tr>
<tr class="separator:aa3b6e5ca13818d030a47748ddeda6aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a9db773c81af2a8ab5b62cfc140fed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structStack.html">AK_stack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#ac8a9db773c81af2a8ab5b62cfc140fed">AK_push_to_stack</a> (int id)</td></tr>
<tr class="memdesc:ac8a9db773c81af2a8ab5b62cfc140fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a entry to the stack.  <a href="#ac8a9db773c81af2a8ab5b62cfc140fed">More...</a><br /></td></tr>
<tr class="separator:ac8a9db773c81af2a8ab5b62cfc140fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2316ab70356027d360cdd0d35b772f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structStack.html">AK_stack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a3f2316ab70356027d360cdd0d35b772f">AK_pop_from_stack</a> ()</td></tr>
<tr class="memdesc:a3f2316ab70356027d360cdd0d35b772f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops a entry to the stack.  <a href="#a3f2316ab70356027d360cdd0d35b772f">More...</a><br /></td></tr>
<tr class="separator:a3f2316ab70356027d360cdd0d35b772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a80c263ba43022ccf949995aae3184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structStack.html">AK_stack</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#af9a80c263ba43022ccf949995aae3184">AK_search_in_stack</a> (int id)</td></tr>
<tr class="memdesc:af9a80c263ba43022ccf949995aae3184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element in the stack.  <a href="#af9a80c263ba43022ccf949995aae3184">More...</a><br /></td></tr>
<tr class="separator:af9a80c263ba43022ccf949995aae3184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839a989703518646d7a3bf386472c79e"><td class="memItemLeft" align="right" valign="top"><a id="a839a989703518646d7a3bf386472c79e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MIN</b> (int X, int Y)</td></tr>
<tr class="separator:a839a989703518646d7a3bf386472c79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3396515c15ff1562d9e04263225974"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#aed3396515c15ff1562d9e04263225974">AK_tarjan</a> (int id)</td></tr>
<tr class="memdesc:aed3396515c15ff1562d9e04263225974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tarjan algorithm that looks for a strongly connected component inside all subgraphs; using DFS.  <a href="#aed3396515c15ff1562d9e04263225974">More...</a><br /></td></tr>
<tr class="separator:aed3396515c15ff1562d9e04263225974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d948548ebb752f203b1de83dced3595"><td class="memItemLeft" align="right" valign="top"><a id="a8d948548ebb752f203b1de83dced3595"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AK_tarjan_test</b> ()</td></tr>
<tr class="separator:a8d948548ebb752f203b1de83dced3595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e3737fb1f7b9c601de9826f82d1aa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAK__synchronization__info.html">AK_synchronization_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#ac5e3737fb1f7b9c601de9826f82d1aa0">AK_init_critical_section</a> ()</td></tr>
<tr class="memdesc:ac5e3737fb1f7b9c601de9826f82d1aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an <a class="el" href="structAK__synchronization__info.html" title="Structure for managing the synchronization between multiple threads accessing the same resources (ess...">AK_synchronization_info</a> structure and returns an owned pointer that must later be passed to AK_destroy_critical_section.  <a href="#ac5e3737fb1f7b9c601de9826f82d1aa0">More...</a><br /></td></tr>
<tr class="separator:ac5e3737fb1f7b9c601de9826f82d1aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba0bb783bbc1cca7523c488a831a662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#aeba0bb783bbc1cca7523c488a831a662">AK_destroy_critical_section</a> (<a class="el" href="structAK__synchronization__info.html">AK_synchronization_info</a> *info)</td></tr>
<tr class="memdesc:aeba0bb783bbc1cca7523c488a831a662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a synchronization object when it is no longer necessary and frees the pointer.  <a href="#aeba0bb783bbc1cca7523c488a831a662">More...</a><br /></td></tr>
<tr class="separator:aeba0bb783bbc1cca7523c488a831a662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310eed330d9ccb91e284f6e73a650a4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a310eed330d9ccb91e284f6e73a650a4e">AK_enter_critical_section</a> (<a class="el" href="structAK__synchronization__info.html">AK_synchronization_info</a> *info)</td></tr>
<tr class="memdesc:a310eed330d9ccb91e284f6e73a650a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters a critical section.  <a href="#a310eed330d9ccb91e284f6e73a650a4e">More...</a><br /></td></tr>
<tr class="separator:a310eed330d9ccb91e284f6e73a650a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896a83e99f01bac3a6512a0efcd305db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a896a83e99f01bac3a6512a0efcd305db">AK_leave_critical_section</a> (<a class="el" href="structAK__synchronization__info.html">AK_synchronization_info</a> *info)</td></tr>
<tr class="memdesc:a896a83e99f01bac3a6512a0efcd305db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leaves a critical section.  <a href="#a896a83e99f01bac3a6512a0efcd305db">More...</a><br /></td></tr>
<tr class="separator:a896a83e99f01bac3a6512a0efcd305db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a378c97f900ed3f928529fccdabbd688e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="auxiliary_8h.html#a378c97f900ed3f928529fccdabbd688e">testMode</a></td></tr>
<tr class="memdesc:a378c97f900ed3f928529fccdabbd688e"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can turn testMode on or off with TEST_MODE_ON and TEST_MODE_OFF. To do this, simply enable or disable it in YOUR function (not in any other!) Test mode can be used when you need some special cases in your functions (i.e., when you are testing some functionality, which doesn't apply in normal conditions). But don't forget to turn this mode off, after you are done (within test function for example)!  <a href="#a378c97f900ed3f928529fccdabbd688e">More...</a><br /></td></tr>
<tr class="separator:a378c97f900ed3f928529fccdabbd688e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file zhat provides data structures for the auxiliary functions </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa5e572792d5472a716c26ef3c4640763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e572792d5472a716c26ef3c4640763">&#9670;&nbsp;</a></span>AK_add_succesor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSuccesor.html">AK_succesor</a> AK_add_succesor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>succesorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>succesorOf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a edge between two nodes. </p>
<dl class="section author"><dt>Author</dt><dd>Frane Jakelić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">succesorId</td><td>id of a newly created edge </td></tr>
    <tr><td class="paramname">succesorOf</td><td>source of the newly created edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the newly created edge </dd></dl>

</div>
</div>
<a id="abb2feed473ff20bcbf39f2552745231c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2feed473ff20bcbf39f2552745231c">&#9670;&nbsp;</a></span>AK_add_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVertex.html">AK_vertex</a> AK_add_vertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that adds a new graph node. </p>
<dl class="section author"><dt>Author</dt><dd>Frane Jakelić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of the vertex that needs to be added </td></tr>
    <tr><td class="paramname">graphRoot</td><td>root node of the graph structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the newly created node </dd></dl>

</div>
</div>
<a id="a19d24287a0675367a7129512792f1ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d24287a0675367a7129512792f1ad7">&#9670;&nbsp;</a></span>AK_chars_num_from_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_chars_num_from_number </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function gets number of digits for given number. </p>
<dl class="section author"><dt>Author</dt><dd>Dino Laktašić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>number to evaluate </td></tr>
    <tr><td class="paramname">int</td><td>base mathematic base (e.g. 2, 10 etc.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of digits for given number </dd></dl>

</div>
</div>
<a id="a16de3836bf0893fef80fac125e07575b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16de3836bf0893fef80fac125e07575b">&#9670;&nbsp;</a></span>Ak_Delete_L3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_Delete_L3 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> **&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> **&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function deletes the current element in the list. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>current element in the list </td></tr>
    <tr><td class="paramname">L</td><td>root of the list  No return value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6886d2e3b64e632490214a10ff750df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6886d2e3b64e632490214a10ff750df1">&#9670;&nbsp;</a></span>Ak_DeleteAll_L3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_DeleteAll_L3 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> **&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function empties list. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
<a id="aeba0bb783bbc1cca7523c488a831a662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba0bb783bbc1cca7523c488a831a662">&#9670;&nbsp;</a></span>AK_destroy_critical_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_destroy_critical_section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__synchronization__info.html">AK_synchronization_info</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a synchronization object when it is no longer necessary and frees the pointer. </p>
<dl class="section author"><dt>Author</dt><dd>Marko Sinko </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Synchronization info structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="adc800c852871e9a9a3ed59736e1324e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc800c852871e9a9a3ed59736e1324e3">&#9670;&nbsp;</a></span>Ak_End_L2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist__node.html">list_node</a>* Ak_End_L2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function gets the last element of the list. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last element of the list </dd></dl>

</div>
</div>
<a id="a310eed330d9ccb91e284f6e73a650a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310eed330d9ccb91e284f6e73a650a4e">&#9670;&nbsp;</a></span>AK_enter_critical_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_enter_critical_section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__synchronization__info.html">AK_synchronization_info</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enters a critical section. </p>
<dl class="section author"><dt>Author</dt><dd>Marko Sinko </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Synchronization info structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="af4b30c1bcfcb82c8f460db1e9d04b3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b30c1bcfcb82c8f460db1e9d04b3ee">&#9670;&nbsp;</a></span>Ak_First_L2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist__node.html">list_node</a>* Ak_First_L2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function gets the first element of the list. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first element of the list </dd></dl>

</div>
</div>
<a id="ad2f8f33ba4112d99a87e6d653ec6fd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f8f33ba4112d99a87e6d653ec6fd4f">&#9670;&nbsp;</a></span>AK_get_array_perms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* AK_get_array_perms </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function gets the position of given element. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SearchElement</td><td>element whose posititon we search for </td></tr>
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the posititon number of some elelemnt </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Dino Laktašić. Get all permutations without repetition (currently not used, but it can be helpful) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>array of chars to permute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char pointer to array of pointers to permuted char arrays </dd></dl>

</div>
</div>
<a id="a96ed0f3a83949f98c6d2b00bbb3f394d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ed0f3a83949f98c6d2b00bbb3f394d">&#9670;&nbsp;</a></span>Ak_GetNth_L2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist__node.html">list_node</a>* Ak_GetNth_L2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function gets a type of the current list element. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Šestak. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>current list element </td></tr>
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data type of the current list element </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matija Šestak. Function gets a data size of the element </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>current list element </td></tr>
    <tr><td class="paramname">L</td><td>- root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data size of the current list element </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić Function for fetching nth element in row </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position of element in row </td></tr>
    <tr><td class="paramname">row</td><td>list of elements of row in table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>element of list of elements of row in table </dd></dl>

</div>
</div>
<a id="ac5e3737fb1f7b9c601de9826f82d1aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e3737fb1f7b9c601de9826f82d1aa0">&#9670;&nbsp;</a></span>AK_init_critical_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAK__synchronization__info.html">AK_synchronization_info</a>* AK_init_critical_section </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an <a class="el" href="structAK__synchronization__info.html" title="Structure for managing the synchronization between multiple threads accessing the same resources (ess...">AK_synchronization_info</a> structure and returns an owned pointer that must later be passed to AK_destroy_critical_section. </p>
<dl class="section author"><dt>Author</dt><dd>Marko Sinko </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Initialized synchronization object </dd></dl>

</div>
</div>
<a id="a1e977cbb8ef0cc8fc7ec3c28ea010f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e977cbb8ef0cc8fc7ec3c28ea010f6f">&#9670;&nbsp;</a></span>Ak_Init_L3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_Init_L3 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> **&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function initializes empty list. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NO return value </dd></dl>

</div>
</div>
<a id="a9c2d039355d7a1087da132ca726ddaa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2d039355d7a1087da132ca726ddaa6">&#9670;&nbsp;</a></span>Ak_InsertAfter_L2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_InsertAfter_L2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> **&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> **&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function inserts new element after the current element in the list. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>new data </td></tr>
    <tr><td class="paramname">current</td><td>current element in the list </td></tr>
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value. </dd></dl>

</div>
</div>
<a id="a288037153643c201561326d464a274cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288037153643c201561326d464a274cd">&#9670;&nbsp;</a></span>Ak_InsertAtBegin_L3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_InsertAtBegin_L3 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function inserts new element at the begin of the list. It uses function AK_InsertBefore_L. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>new data </td></tr>
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
<a id="a44b85b3038e088b9a1609b1ec173dc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b85b3038e088b9a1609b1ec173dc81">&#9670;&nbsp;</a></span>Ak_InsertAtEnd_L3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_InsertAtEnd_L3 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function inserts new element at the end of the list. It uses function Ak_InsertAfter_L2. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>new data </td></tr>
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value. </dd></dl>

</div>
</div>
<a id="ac54bcef3f0e783a9bcebc1ca646e89c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54bcef3f0e783a9bcebc1ca646e89c6">&#9670;&nbsp;</a></span>Ak_InsertBefore_L2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ak_InsertBefore_L2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> **&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> **&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function inserts new element before the current element in the list. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>new data </td></tr>
    <tr><td class="paramname">current</td><td>current element in the list </td></tr>
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
<a id="aa3331f9738966d0474068e676432fb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3331f9738966d0474068e676432fb69">&#9670;&nbsp;</a></span>Ak_IsEmpty_L2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Ak_IsEmpty_L2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function tests whether the list is empty. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the list is empty, otherwise returns 0 </dd></dl>

</div>
</div>
<a id="a896a83e99f01bac3a6512a0efcd305db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896a83e99f01bac3a6512a0efcd305db">&#9670;&nbsp;</a></span>AK_leave_critical_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_leave_critical_section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__synchronization__info.html">AK_synchronization_info</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leaves a critical section. </p>
<dl class="section author"><dt>Author</dt><dd>Marko Sinko </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Synchronization info structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a9b623eddf3baccd6b792e460d23b9145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b623eddf3baccd6b792e460d23b9145">&#9670;&nbsp;</a></span>Ak_Next_L2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist__node.html">list_node</a>* Ak_Next_L2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>current</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function gets the next element of the list. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>current element in the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next element in the list </dd></dl>

</div>
</div>
<a id="a3f2316ab70356027d360cdd0d35b772f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2316ab70356027d360cdd0d35b772f">&#9670;&nbsp;</a></span>AK_pop_from_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structStack.html">AK_stack</a> AK_pop_from_stack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops a entry to the stack. </p>
<dl class="section author"><dt>Author</dt><dd>Frane Jakelić </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the popped stack node </dd></dl>

</div>
</div>
<a id="ab3256c93947b5866b09f76abd953a86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3256c93947b5866b09f76abd953a86d">&#9670;&nbsp;</a></span>Ak_Previous_L2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist__node.html">list_node</a>* Ak_Previous_L2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function gets the previous element of the list. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>current element in the list </td></tr>
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous element in the list </dd></dl>

</div>
</div>
<a id="ac8a9db773c81af2a8ab5b62cfc140fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a9db773c81af2a8ab5b62cfc140fed">&#9670;&nbsp;</a></span>AK_push_to_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structStack.html">AK_stack</a> AK_push_to_stack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a entry to the stack. </p>
<dl class="section author"><dt>Author</dt><dd>Frane Jakelić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of the element that is being added to the stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the newly added stack node </dd></dl>

</div>
</div>
<a id="a87fee7fbe9ba42288d7376b95c6f1afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fee7fbe9ba42288d7376b95c6f1afe">&#9670;&nbsp;</a></span>Ak_Retrieve_L2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* Ak_Retrieve_L2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function retrieves data from the current element in the list. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>current element in the list </td></tr>
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data from the list element </dd></dl>

</div>
</div>
<a id="ae087a85c200788e13f21d82561b11b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae087a85c200788e13f21d82561b11b11">&#9670;&nbsp;</a></span>AK_search_empty_link()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVertex.html">AK_vertex</a> AK_search_empty_link </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Frane Jakelić  for empty link for a new graph node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphRoot</td><td>oot node of the graph structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>empty link for new graph node </dd></dl>

</div>
</div>
<a id="aa3b6e5ca13818d030a47748ddeda6aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b6e5ca13818d030a47748ddeda6aec">&#9670;&nbsp;</a></span>AK_search_empty_stack_link()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structStack.html">AK_stack</a> AK_search_empty_stack_link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStack.html">AK_stack</a>&#160;</td>
          <td class="paramname"><em>stackRoot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a empty link for the stack. </p>
<dl class="section author"><dt>Author</dt><dd>Frane Jakelić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stackRoot</td><td>root node of the selected stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the empty link </dd></dl>

</div>
</div>
<a id="af9a80c263ba43022ccf949995aae3184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a80c263ba43022ccf949995aae3184">&#9670;&nbsp;</a></span>AK_search_in_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structStack.html">AK_stack</a> AK_search_in_stack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an element in the stack. </p>
<dl class="section author"><dt>Author</dt><dd>Frane Jakelić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of the node that needs to be found in the stac </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the found stack node </dd></dl>

</div>
</div>
<a id="a6f5f350b143545f5fbe03da908bf9327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5f350b143545f5fbe03da908bf9327">&#9670;&nbsp;</a></span>AK_search_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVertex.html">AK_vertex</a> AK_search_vertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Frane Jakelić  that searches for a specific graph node by its ID </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of the vertex that needs to be found </td></tr>
    <tr><td class="paramname">graphRoot</td><td>root node of the graph structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>found graph nod or null </dd></dl>

</div>
</div>
<a id="aea432955394feccab4cb8175bf616214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea432955394feccab4cb8175bf616214">&#9670;&nbsp;</a></span>Ak_Size_L2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ak_Size_L2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist__node.html">list_node</a> *&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function gets a number of the elements in the list. </p>
<dl class="section author"><dt>Author</dt><dd>Ljiljana Pintarić. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>root of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the list </dd></dl>

</div>
</div>
<a id="a7ef0a3434550001b2aa3364e4018a917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef0a3434550001b2aa3364e4018a917">&#9670;&nbsp;</a></span>AK_strcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_strcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function compares to Strings. </p>
<dl class="section author"><dt>Author</dt><dd>Dino Laktašić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*a</td><td>pointer of value to compare </td></tr>
    <tr><td class="paramname">*b</td><td>pointer of value to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of comparison according to strcmp function </dd></dl>

</div>
</div>
<a id="aed3396515c15ff1562d9e04263225974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3396515c15ff1562d9e04263225974">&#9670;&nbsp;</a></span>AK_tarjan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_tarjan </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tarjan algorithm that looks for a strongly connected component inside all subgraphs; using DFS. </p>
<dl class="section author"><dt>Author</dt><dd>Frane Jakelić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of the element on which the algorithm looks for a id of a strongly connected component </td></tr>
  </table>
  </dd>
</dl>
<h6>#### connected component. Edges:");</h6>
<h6>####");</h6>

</div>
</div>
<a id="a46c96419e17650737bae8af0dfdb399f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c96419e17650737bae8af0dfdb399f">&#9670;&nbsp;</a></span>AK_type_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t AK_type_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iDB_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szVarchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function returns size in bytes of the provided database type. </p>
<dl class="section author"><dt>Author</dt><dd>Miroslav Policki </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iDB_type</td><td>database data type (defined in <a class="el" href="constants_8h.html">constants.h</a>) </td></tr>
    <tr><td class="paramname">szVarchar</td><td>if iDB_type == TYPE_VARCHAR, pointer to the string, otherwise unused </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of provided data type in bytes if provided data type is valid, else 0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a378c97f900ed3f928529fccdabbd688e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378c97f900ed3f928529fccdabbd688e">&#9670;&nbsp;</a></span>testMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">testMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You can turn testMode on or off with TEST_MODE_ON and TEST_MODE_OFF. To do this, simply enable or disable it in YOUR function (not in any other!) Test mode can be used when you need some special cases in your functions (i.e., when you are testing some functionality, which doesn't apply in normal conditions). But don't forget to turn this mode off, after you are done (within test function for example)! </p>
<dl class="section author"><dt>Author</dt><dd>Domagoj Šitum </dd></dl>

</div>
</div>
</div><!-- contents -->

